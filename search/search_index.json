{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ICPC.NINJA SHARE & GET useful problem solving techniques Why I created this site? Ipsum nemo veritatis illum nulla veniam. Aut esse blanditiis placeat omnis culpa. Odit iusto repudiandae dolorem molestiae labore. Sed a dolores iusto esse placeat officia Obcaecati corporis perspiciatis sequi consequatur. How I created this site? Dolor eveniet incidunt esse nostrum dolor Cumque totam veniam dolore culpa sapiente Repudiandae velit odit magni commodi quasi? Voluptates officiis ab veniam eos totam Dolorem commodi deleniti unde adipisci nihil How to contribute Dolor vitae soluta praesentium obcaecati minus Enim consequuntur expedita voluptatibus eius dignissimos Praesentium provident commodi natus quisquam amet! Eum illo nisi laboriosam rem veritatis Excepturi sed assumenda libero qui accusamus? emojis","title":"Home"},{"location":"#welcome-to-icpcninja","text":"SHARE & GET useful problem solving techniques","title":"Welcome to ICPC.NINJA"},{"location":"#why-i-created-this-site","text":"Ipsum nemo veritatis illum nulla veniam. Aut esse blanditiis placeat omnis culpa. Odit iusto repudiandae dolorem molestiae labore. Sed a dolores iusto esse placeat officia Obcaecati corporis perspiciatis sequi consequatur.","title":"Why I created this site?"},{"location":"#how-i-created-this-site","text":"Dolor eveniet incidunt esse nostrum dolor Cumque totam veniam dolore culpa sapiente Repudiandae velit odit magni commodi quasi? Voluptates officiis ab veniam eos totam Dolorem commodi deleniti unde adipisci nihil","title":"How I created this site?"},{"location":"#how-to-contribute","text":"Dolor vitae soluta praesentium obcaecati minus Enim consequuntur expedita voluptatibus eius dignissimos Praesentium provident commodi natus quisquam amet! Eum illo nisi laboriosam rem veritatis Excepturi sed assumenda libero qui accusamus?","title":"How to contribute"},{"location":"#emojis","text":"","title":"emojis"},{"location":"PlaceHolder/","text":"Place Holder Place holder Hello world 1 2 3 4 5 6 7 #include <iostream> using namespace std ; int main () { cout << \"Hello World!\" << '\\n' ; return 0 ; } Info this is place holder text this is place holder","title":"Preface"},{"location":"PlaceHolder/#place-holder","text":"Place holder","title":"Place Holder"},{"location":"PlaceHolder/#hello-world","text":"1 2 3 4 5 6 7 #include <iostream> using namespace std ; int main () { cout << \"Hello World!\" << '\\n' ; return 0 ; } Info this is place holder text this is place holder","title":"Hello world"},{"location":"DataStructures/Stack/","text":"Stack Element deleted from the set is the one most recently inserted; Stack implements last-in, first out or LIFO policy You can use array to implement Stack supported operations The INSERT operation on a stack is often called PUSH, and the DELETE operation, which does not take an argument, is often called POP. 0. STEP0 maintain an array ${S}[{1,2,3, ..., n}]$ 1. PUSH() 2. POP() 3. EMPTY() $$ \\begin{array}{cccc} 0 & 1 & 2 & 3 \\\\ \\hline \\text{COW} & \\text{SE$\\textbf{A}$} & \\text{T$\\textbf{A}$B} & \\text{$\\textbf{B}$AR} \\\\ \\text{DOG} & \\text{TE$\\textbf{A}$} & \\text{B$\\textbf{A}$R} & \\text{$\\textbf{B}$IG} \\\\ \\text{SEA} & \\text{MO$\\textbf{B}$} & \\text{E$\\textbf{A}$R} & \\text{$\\textbf{B}$OX} \\\\ \\text{RUG} & \\text{TA$\\textbf{B}$} & \\text{T$\\textbf{A}$R} & \\text{$\\textbf{C}$OW} \\\\ \\text{ROW} & \\text{DO$\\textbf{G}$} & \\text{S$\\textbf{E}$A} & \\text{$\\textbf{D}$IG} \\\\ \\text{MOB} & \\text{RU$\\textbf{G}$} & \\text{T$\\textbf{E}$A} & \\text{$\\textbf{D}$OG} \\\\ \\text{BOX} & \\text{DI$\\textbf{G}$} & \\text{D$\\textbf{I}$G} & \\text{$\\textbf{E}$AR} \\\\ \\text{TAB} & \\text{BI$\\textbf{G}$} & \\text{B$\\textbf{I}$G} & \\text{$\\textbf{F}$OX} \\\\ \\text{BAR} & \\text{BA$\\textbf{R}$} & \\text{M$\\textbf{O}$B} & \\text{$\\textbf{M}$OB} \\\\ \\text{EAR} & \\text{EA$\\textbf{R}$} & \\text{D$\\textbf{O}$G} & \\text{$\\textbf{N}$OW} \\\\ \\text{TAR} & \\text{TA$\\textbf{R}$} & \\text{C$\\textbf{O}$W} & \\text{$\\textbf{R}$OW} \\\\ \\text{DIG} & \\text{CO$\\textbf{W}$} & \\text{R$\\textbf{O}$W} & \\text{$\\textbf{R}$UG} \\\\ \\text{BIG} & \\text{RO$\\textbf{W}$} & \\text{N$\\textbf{O}$W} & \\text{$\\textbf{S}$EA} \\\\ \\text{TEA} & \\text{NO$\\textbf{W}$} & \\text{B$\\textbf{O}$X} & \\text{$\\textbf{T}$AB} \\\\ \\text{NOW} & \\text{BO$\\textbf{X}$} & \\text{F$\\textbf{O}$X} & \\text{$\\textbf{T}$AR} \\\\ \\text{FOX} & \\text{FO$\\textbf{X}$} & \\text{R$\\textbf{U}$G} & \\text{$\\textbf{T}$EA} \\\\ \\end{array} $$","title":"Stack"},{"location":"DataStructures/Stack/#stack","text":"Element deleted from the set is the one most recently inserted; Stack implements last-in, first out or LIFO policy You can use array to implement Stack","title":"Stack"},{"location":"DataStructures/Stack/#supported-operations","text":"The INSERT operation on a stack is often called PUSH, and the DELETE operation, which does not take an argument, is often called POP.","title":"supported operations"},{"location":"DataStructures/Stack/#0-step0","text":"maintain an array ${S}[{1,2,3, ..., n}]$","title":"0. STEP0"},{"location":"DataStructures/Stack/#1-push","text":"","title":"1. PUSH()"},{"location":"DataStructures/Stack/#2-pop","text":"","title":"2. POP()"},{"location":"DataStructures/Stack/#3-empty","text":"$$ \\begin{array}{cccc} 0 & 1 & 2 & 3 \\\\ \\hline \\text{COW} & \\text{SE$\\textbf{A}$} & \\text{T$\\textbf{A}$B} & \\text{$\\textbf{B}$AR} \\\\ \\text{DOG} & \\text{TE$\\textbf{A}$} & \\text{B$\\textbf{A}$R} & \\text{$\\textbf{B}$IG} \\\\ \\text{SEA} & \\text{MO$\\textbf{B}$} & \\text{E$\\textbf{A}$R} & \\text{$\\textbf{B}$OX} \\\\ \\text{RUG} & \\text{TA$\\textbf{B}$} & \\text{T$\\textbf{A}$R} & \\text{$\\textbf{C}$OW} \\\\ \\text{ROW} & \\text{DO$\\textbf{G}$} & \\text{S$\\textbf{E}$A} & \\text{$\\textbf{D}$IG} \\\\ \\text{MOB} & \\text{RU$\\textbf{G}$} & \\text{T$\\textbf{E}$A} & \\text{$\\textbf{D}$OG} \\\\ \\text{BOX} & \\text{DI$\\textbf{G}$} & \\text{D$\\textbf{I}$G} & \\text{$\\textbf{E}$AR} \\\\ \\text{TAB} & \\text{BI$\\textbf{G}$} & \\text{B$\\textbf{I}$G} & \\text{$\\textbf{F}$OX} \\\\ \\text{BAR} & \\text{BA$\\textbf{R}$} & \\text{M$\\textbf{O}$B} & \\text{$\\textbf{M}$OB} \\\\ \\text{EAR} & \\text{EA$\\textbf{R}$} & \\text{D$\\textbf{O}$G} & \\text{$\\textbf{N}$OW} \\\\ \\text{TAR} & \\text{TA$\\textbf{R}$} & \\text{C$\\textbf{O}$W} & \\text{$\\textbf{R}$OW} \\\\ \\text{DIG} & \\text{CO$\\textbf{W}$} & \\text{R$\\textbf{O}$W} & \\text{$\\textbf{R}$UG} \\\\ \\text{BIG} & \\text{RO$\\textbf{W}$} & \\text{N$\\textbf{O}$W} & \\text{$\\textbf{S}$EA} \\\\ \\text{TEA} & \\text{NO$\\textbf{W}$} & \\text{B$\\textbf{O}$X} & \\text{$\\textbf{T}$AB} \\\\ \\text{NOW} & \\text{BO$\\textbf{X}$} & \\text{F$\\textbf{O}$X} & \\text{$\\textbf{T}$AR} \\\\ \\text{FOX} & \\text{FO$\\textbf{X}$} & \\text{R$\\textbf{U}$G} & \\text{$\\textbf{T}$EA} \\\\ \\end{array} $$","title":"3. EMPTY()"},{"location":"DataStructures/HashTables/HashFunctions/","text":"Hash Function A hash function is any function that can be used to map data of arbitrary size onto data of a fixed size. Hash Functions 1. DJB2 this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c. another version of this algorithm (now favored by bernstein) uses xor: hash(i) = hash(i-1) * 33 ^ str[i]; the magic of number 33 (why it works better than many other constants, prime or not) has never adequately explained 1 2 3 4 5 6 7 8 9 #define ll unsigned long long unsigned long long djb2 ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = ( hash << 5 ) + hash + c ; //equivalent to hash = hash * 33 + c; } return hash ; } 2. sdbm this algorithm was created for sdbm (a public-domain reimplementation of ndbm) database library. it was found to do well in scrambling bits, causing better distribution of the keys and fewer splits. it also happens to be a good general hashing function with good distribution. the actual function is hash(i) = hash(i - 1) * 65599 + str[i];; what is included below is faster version used in gawk. (there iseven a faster, duff's device version) the magic constant 65599 was picked out of thin air while experimenting with different constants, and turns out to be a prime. this is one of the algorithms used in berkeley db (see sleepy cat) and else where 1 2 3 4 5 6 7 8 9 10 11 12 #define ll unsigned long long unsigned long long djb2 ( char * str ) { unsigned long long hash = 0 ; int c ; while (( c = * ( str ++ ))) { hash = c + ( hash << 6 ) + ( hash << 16 ) - hash ; } return hash ; } 3. lose lose This hash function appeared in K&R (1st ed) but at least the reader was warned: \"This is not the best possible algorithm, but it has the merit of extreme simplicity\". This is an understatement; It is a terrible hashing algorithm, and it could have been much better without scarificing its \"extreme simplicity.\" Many C programmers use this function without actually testing it, or checking something like Knuth's Sorting and searching, so it stuck. It is now found mixed with other respectable code, eg.cnews. Warning Don't use this algorithm, it's terrible. 1 2 3 4 5 6 7 8 9 10 11 12 #define ll unsigned long long ll loseLose ( char * str ) { ll hash = 0 ; int c ; while ( c = * str ++ ) { hash += c ; } return hash }","title":"Hash Functions"},{"location":"DataStructures/HashTables/HashFunctions/#hash-function","text":"A hash function is any function that can be used to map data of arbitrary size onto data of a fixed size.","title":"Hash Function"},{"location":"DataStructures/HashTables/HashFunctions/#hash-functions","text":"","title":"Hash Functions"},{"location":"DataStructures/HashTables/HashFunctions/#1-djb2","text":"this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c. another version of this algorithm (now favored by bernstein) uses xor: hash(i) = hash(i-1) * 33 ^ str[i]; the magic of number 33 (why it works better than many other constants, prime or not) has never adequately explained 1 2 3 4 5 6 7 8 9 #define ll unsigned long long unsigned long long djb2 ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = ( hash << 5 ) + hash + c ; //equivalent to hash = hash * 33 + c; } return hash ; }","title":"1. DJB2"},{"location":"DataStructures/HashTables/HashFunctions/#2-sdbm","text":"this algorithm was created for sdbm (a public-domain reimplementation of ndbm) database library. it was found to do well in scrambling bits, causing better distribution of the keys and fewer splits. it also happens to be a good general hashing function with good distribution. the actual function is hash(i) = hash(i - 1) * 65599 + str[i];; what is included below is faster version used in gawk. (there iseven a faster, duff's device version) the magic constant 65599 was picked out of thin air while experimenting with different constants, and turns out to be a prime. this is one of the algorithms used in berkeley db (see sleepy cat) and else where 1 2 3 4 5 6 7 8 9 10 11 12 #define ll unsigned long long unsigned long long djb2 ( char * str ) { unsigned long long hash = 0 ; int c ; while (( c = * ( str ++ ))) { hash = c + ( hash << 6 ) + ( hash << 16 ) - hash ; } return hash ; }","title":"2. sdbm"},{"location":"DataStructures/HashTables/HashFunctions/#3-lose-lose","text":"This hash function appeared in K&R (1st ed) but at least the reader was warned: \"This is not the best possible algorithm, but it has the merit of extreme simplicity\". This is an understatement; It is a terrible hashing algorithm, and it could have been much better without scarificing its \"extreme simplicity.\" Many C programmers use this function without actually testing it, or checking something like Knuth's Sorting and searching, so it stuck. It is now found mixed with other respectable code, eg.cnews. Warning Don't use this algorithm, it's terrible. 1 2 3 4 5 6 7 8 9 10 11 12 #define ll unsigned long long ll loseLose ( char * str ) { ll hash = 0 ; int c ; while ( c = * str ++ ) { hash += c ; } return hash }","title":"3. lose lose"}]}