{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"THIS SITE IS UNDER CONSTRUCTION Welcome to ICPC.NINJA SHARE & GET useful problem solving techniques All Articles in this site is implemented on c++17 Why I created this site? Ipsum nemo veritatis illum nulla veniam. Aut esse blanditiis placeat omnis culpa. Odit iusto repudiandae dolorem molestiae labore. Sed a dolores iusto esse placeat officia Obcaecati corporis perspiciatis sequi consequatur. How I created this site? Dolor eveniet incidunt esse nostrum dolor Cumque totam veniam dolore culpa sapiente Repudiandae velit odit magni commodi quasi? Voluptates officiis ab veniam eos totam Dolorem commodi deleniti unde adipisci nihil How to contribute Dolor vitae soluta praesentium obcaecati minus Enim consequuntur expedita voluptatibus eius dignissimos Praesentium provident commodi natus quisquam amet! Eum illo nisi laboriosam rem veritatis Excepturi sed assumenda libero qui accusamus? emojis","title":"Home"},{"location":"#this-site-is-under-construction","text":"","title":"THIS SITE IS UNDER CONSTRUCTION"},{"location":"#welcome-to-icpcninja","text":"SHARE & GET useful problem solving techniques All Articles in this site is implemented on c++17","title":"Welcome to ICPC.NINJA"},{"location":"#why-i-created-this-site","text":"Ipsum nemo veritatis illum nulla veniam. Aut esse blanditiis placeat omnis culpa. Odit iusto repudiandae dolorem molestiae labore. Sed a dolores iusto esse placeat officia Obcaecati corporis perspiciatis sequi consequatur.","title":"Why I created this site?"},{"location":"#how-i-created-this-site","text":"Dolor eveniet incidunt esse nostrum dolor Cumque totam veniam dolore culpa sapiente Repudiandae velit odit magni commodi quasi? Voluptates officiis ab veniam eos totam Dolorem commodi deleniti unde adipisci nihil","title":"How I created this site?"},{"location":"#how-to-contribute","text":"Dolor vitae soluta praesentium obcaecati minus Enim consequuntur expedita voluptatibus eius dignissimos Praesentium provident commodi natus quisquam amet! Eum illo nisi laboriosam rem veritatis Excepturi sed assumenda libero qui accusamus?","title":"How to contribute"},{"location":"#emojis","text":"","title":"emojis"},{"location":"PlaceHolder/","text":"Place Holder Place holder Hello world 1 2 3 4 5 6 7 #include <iostream> using namespace std ; int main () { cout << \"Hello World!\" << '\\n' ; return 0 ; } Info this is place holder text this is place holder","title":"Problems"},{"location":"PlaceHolder/#place-holder","text":"Place holder","title":"Place Holder"},{"location":"PlaceHolder/#hello-world","text":"1 2 3 4 5 6 7 #include <iostream> using namespace std ; int main () { cout << \"Hello World!\" << '\\n' ; return 0 ; } Info this is place holder text this is place holder","title":"Hello world"},{"location":"Algorithms/Graph/DFS/Preface/","text":"DFS The most useful graph algorithms are search algorithms. DFS(Depth First Search) is one of them. While running DFS, we assign colors to the vertices (initially white) Algorithm itself is really simple 1 2 3 4 5 6 dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black Black color here is not used, but you can use it sometimes. Time complexity: $O(n + m)$","title":"Preface"},{"location":"Algorithms/Graph/DFS/Preface/#dfs","text":"The most useful graph algorithms are search algorithms. DFS(Depth First Search) is one of them. While running DFS, we assign colors to the vertices (initially white) Algorithm itself is really simple 1 2 3 4 5 6 dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black Black color here is not used, but you can use it sometimes. Time complexity: $O(n + m)$","title":"DFS"},{"location":"Algorithms/Graph/DFS/StartingFinishingTime/","text":"Starting time, finishing time Starting time of a vertex is the time we enter it (the order we enter it) and its finishing time is the time we leave it. Calculating these are easy 1 2 3 4 5 6 7 8 9 TIME = 0 dfs ( v ): st [ v ] = TIME ++ color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black ft [ v ] = TIME # or we can use TIME ++ It is useable in specially data structure problems (convert the tree into an array). Lemma : if we run $dfs(root)$ in a rooted tree, then v is an ancestor of $u$ if and only if $st_v\\leq st_u\\leq ft_u\\leq ft_v$. So, given arrays $st$ and $ft$ we can rebuild the tree.","title":"StartingFinishingTime"},{"location":"Algorithms/Graph/DFS/StartingFinishingTime/#starting-time-finishing-time","text":"Starting time of a vertex is the time we enter it (the order we enter it) and its finishing time is the time we leave it. Calculating these are easy 1 2 3 4 5 6 7 8 9 TIME = 0 dfs ( v ): st [ v ] = TIME ++ color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black ft [ v ] = TIME # or we can use TIME ++ It is useable in specially data structure problems (convert the tree into an array). Lemma : if we run $dfs(root)$ in a rooted tree, then v is an ancestor of $u$ if and only if $st_v\\leq st_u\\leq ft_u\\leq ft_v$. So, given arrays $st$ and $ft$ we can rebuild the tree.","title":"Starting time, finishing time"},{"location":"Algorithms/Graph/DFS/Tree/","text":"DFS tree DFS Tree is a rooted tree that is built like this 1 2 3 4 5 6 7 let T be a new tree dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) and par [ u ] = v ( in T ) color [ v ] = black Lemma : There is no cross edges, it means if there is an edge between $V$ and $u$, then $v=par[u]$ or $u=par[v]$","title":"DFSTree"},{"location":"Algorithms/Graph/DFS/Tree/#dfs-tree","text":"DFS Tree is a rooted tree that is built like this 1 2 3 4 5 6 7 let T be a new tree dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) and par [ u ] = v ( in T ) color [ v ] = black Lemma : There is no cross edges, it means if there is an edge between $V$ and $u$, then $v=par[u]$ or $u=par[v]$","title":"DFS tree"},{"location":"Algorithms/Sort/BubbleSort/","text":"Bubble Sort Bubble Sort C++ 1 2 3 4 5 6 7 8 9 template < typename It > void BubbleSort ( It begin , It end ) { if ( begin == end ) return ; //return if container is empty for ( It i = end - 1 ; i != begin ; i -- ) { for ( It j = begin ; j != i ; j ++ ) { if ( * j > * ( j + 1 )) swap ( * j , * ( j + 1 )); } } }","title":"BubbleSort"},{"location":"Algorithms/Sort/BubbleSort/#bubble-sort","text":"Bubble Sort","title":"Bubble Sort"},{"location":"Algorithms/Sort/BubbleSort/#c","text":"1 2 3 4 5 6 7 8 9 template < typename It > void BubbleSort ( It begin , It end ) { if ( begin == end ) return ; //return if container is empty for ( It i = end - 1 ; i != begin ; i -- ) { for ( It j = begin ; j != i ; j ++ ) { if ( * j > * ( j + 1 )) swap ( * j , * ( j + 1 )); } } }","title":"C++"},{"location":"Algorithms/Sort/InsertionSort/","text":"Insertion Sort Insertion Sort is very simple algorithm it works exactly like the way you sort a deck of card C++ 1 2 3 4 5 6 7 8 9 10 template < typenme It > // Iterator void insertionSort ( It begin , It end ) { //TODO add comparator if ( begin == end ) return ; // return if container is empty for ( It i = begin ; i != end ; i ++ ) { for ( It j = i ; j != begin ; j -- ) { if ( * ( j - 1 ) < * j ) break ; swap ( * ( j - 1 ), * j ); } } }","title":"InsertionSort"},{"location":"Algorithms/Sort/InsertionSort/#insertion-sort","text":"Insertion Sort is very simple algorithm it works exactly like the way you sort a deck of card","title":"Insertion Sort"},{"location":"Algorithms/Sort/InsertionSort/#c","text":"1 2 3 4 5 6 7 8 9 10 template < typenme It > // Iterator void insertionSort ( It begin , It end ) { //TODO add comparator if ( begin == end ) return ; // return if container is empty for ( It i = begin ; i != end ; i ++ ) { for ( It j = i ; j != begin ; j -- ) { if ( * ( j - 1 ) < * j ) break ; swap ( * ( j - 1 ), * j ); } } }","title":"C++"},{"location":"Contribute/Emoji/","text":"People :bowtie: :smile: :laughing: :blush: :smiley: :relaxed: :smirk: :heart_eyes: :kissing_heart: :kissing_closed_eyes: :flushed: :relieved: :satisfied: :grin: :wink: :stuck_out_tongue_winking_eye: :stuck_out_tongue_closed_eyes: :grinning: :kissing: :kissing_smiling_eyes: :stuck_out_tongue: :sleeping: :worried: :frowning: :anguished: :open_mouth: :grimacing: :confused: :hushed: :expressionless: :unamused: :sweat_smile: :sweat: :disappointed_relieved: :weary: :pensive: :disappointed: :confounded: :fearful: :cold_sweat: :persevere: :cry: :sob: :joy: :astonished: :scream: :neckbeard: :tired_face: :angry: :rage: :triumph: :sleepy: :yum: :mask: :sunglasses: :dizzy_face: :imp: :smiling_imp: :neutral_face: :no_mouth: :innocent: :alien: :yellow_heart: :blue_heart: :purple_heart: :heart: :green_heart: :broken_heart: :heartbeat: :heartpulse: :two_hearts: :revolving_hearts: :cupid: :sparkling_heart: :sparkles: :star: :star2: :dizzy: :boom: :collision: :anger: :exclamation: :question: :grey_exclamation: :grey_question: :zzz: :dash: :sweat_drops: :notes: :musical_note: :fire: :hankey: :poop: :shit: :+1: :thumbsup: :-1: :thumbsdown: :ok_hand: :punch: :facepunch: :fist: :v: :wave: :hand: :raised_hand: :open_hands: :point_up: :point_down: :point_left: :point_right: :raised_hands: :pray: :point_up_2: :clap: :muscle: :metal: :fu: :walking: :runner: :running: :couple: :family: :two_men_holding_hands: :two_women_holding_hands: :dancer: :dancers: :ok_woman: :no_good: :information_desk_person: :raising_hand: :bride_with_veil: :person_with_pouting_face: :person_frowning: :bow: :couplekiss: :couplekiss: :couple_with_heart: :massage: :haircut: :nail_care: :boy: :girl: :woman: :man: :baby: :older_woman: :older_man: :person_with_blond_hair: :man_with_gua_pi_mao: :man_with_turban: :construction_worker: :cop: :angel: :princess: :smiley_cat: :smile_cat: :heart_eyes_cat: :kissing_cat: :smirk_cat: :scream_cat: :crying_cat_face: :joy_cat: :pouting_cat: :japanese_ogre: :japanese_goblin: :see_no_evil: :hear_no_evil: :speak_no_evil: :guardsman: :skull: :feet: :lips: :kiss: :droplet: :ear: :eyes: :nose: :tongue: :love_letter: :bust_in_silhouette: :busts_in_silhouette: :speech_balloon: :thought_balloon: :feelsgood: :finnadie: :goberserk: :godmode: :hurtrealbad: :rage1: :rage2: :rage3: :rage4: :suspect: :trollface: Nature :sunny: :umbrella: :cloud: :snowflake: :snowman: :zap: :cyclone: :foggy: :ocean: :cat: :dog: :mouse: :hamster: :rabbit: :wolf: :frog: :tiger: :koala: :bear: :pig: :pig_nose: :cow: :boar: :monkey_face: :monkey: :horse: :racehorse: :camel: :sheep: :elephant: :panda_face: :snake: :bird: :baby_chick: :hatched_chick: :hatching_chick: :chicken: :penguin: :turtle: :bug: :honeybee: :ant: :beetle: :snail: :octopus: :tropical_fish: :fish: :whale: :whale2: :dolphin: :cow2: :ram: :rat: :water_buffalo: :tiger2: :rabbit2: :dragon: :goat: :rooster: :dog2: :pig2: :mouse2: :ox: :dragon_face: :blowfish: :crocodile: :dromedary_camel: :leopard: :cat2: :poodle: :paw_prints: :bouquet: :cherry_blossom: :tulip: :four_leaf_clover: :rose: :sunflower: :hibiscus: :maple_leaf: :leaves: :fallen_leaf: :herb: :mushroom: :cactus: :palm_tree: :evergreen_tree: :deciduous_tree: :chestnut: :seedling: :blossom: :ear_of_rice: :shell: :globe_with_meridians: :sun_with_face: :full_moon_with_face: :new_moon_with_face: :new_moon: :waxing_crescent_moon: :first_quarter_moon: :waxing_gibbous_moon: :full_moon: :waning_gibbous_moon: :last_quarter_moon: :waning_crescent_moon: :last_quarter_moon_with_face: :first_quarter_moon_with_face: :moon: :earth_africa: :earth_americas: :earth_asia: :volcano: :milky_way: :partly_sunny: :octocat: :squirrel: Objects :bamboo: :gift_heart: :dolls: :school_satchel: :mortar_board: :flags: :fireworks: :sparkler: :wind_chime: :rice_scene: :jack_o_lantern: :ghost: :santa: :christmas_tree: :gift: :bell: :no_bell: :tanabata_tree: :tada: :confetti_ball: :balloon: :crystal_ball: :cd: :dvd: :floppy_disk: :camera: :video_camera: :movie_camera: :computer: :tv: :iphone: :phone: :telephone: :telephone_receiver: :pager: :fax: :minidisc: :vhs: :sound: :speaker: :mute: :loudspeaker: :mega: :hourglass: :hourglass_flowing_sand: :alarm_clock: :watch: :radio: :satellite: :loop: :mag: :mag_right: :unlock: :lock: :lock_with_ink_pen: :closed_lock_with_key: :key: :bulb: :flashlight: :high_brightness: :low_brightness: :electric_plug: :battery: :calling: :email: :mailbox: :postbox: :bath: :bathtub: :shower: :toilet: :wrench: :nut_and_bolt: :hammer: :seat: :moneybag: :yen: :dollar: :pound: :euro: :credit_card: :money_with_wings: :e-mail: :inbox_tray: :outbox_tray: :envelope: :incoming_envelope: :postal_horn: :mailbox_closed: :mailbox_with_mail: :mailbox_with_no_mail: :door: :smoking: :bomb: :gun: :hocho: :pill: :syringe: :page_facing_up: :page_with_curl: :bookmark_tabs: :bar_chart: :chart_with_upwards_trend: :chart_with_downwards_trend: :scroll: :clipboard: :calendar: :date: :card_index: :file_folder: :open_file_folder: :scissors: :pushpin: :paperclip: :black_nib: :pencil2: :straight_ruler: :triangular_ruler: :closed_book: :green_book: :blue_book: :orange_book: :notebook: :notebook_with_decorative_cover: :ledger: :books: :bookmark: :name_badge: :microscope: :telescope: :newspaper: :football: :basketball: :soccer: :baseball: :tennis: :8ball: :rugby_football: :bowling: :golf: :mountain_bicyclist: :bicyclist: :horse_racing: :snowboarder: :swimmer: :surfer: :ski: :spades: :hearts: :clubs: :diamonds: :gem: :ring: :trophy: :musical_score: :musical_keyboard: :violin: :space_invader: :video_game: :black_joker: :flower_playing_cards: :game_die: :dart: :mahjong: :clapper: :memo: :pencil: :book: :art: :microphone: :headphones: :trumpet: :saxophone: :guitar: :shoe: :sandal: :high_heel: :lipstick: :boot: :shirt: :tshirt: :necktie: :womans_clothes: :dress: :running_shirt_with_sash: :jeans: :kimono: :bikini: :ribbon: :tophat: :crown: :womans_hat: :mans_shoe: :closed_umbrella: :briefcase: :handbag: :pouch: :purse: :eyeglasses: :fishing_pole_and_fish: :coffee: :tea: :sake: :baby_bottle: :beer: :beers: :cocktail: :tropical_drink: :wine_glass: :fork_and_knife: :pizza: :hamburger: :fries: :poultry_leg: :meat_on_bone: :spaghetti: :curry: :fried_shrimp: :bento: :sushi: :fish_cake: :rice_ball: :rice_cracker: :rice: :ramen: :stew: :oden: :dango: :egg: :bread: :doughnut: :custard: :icecream: :ice_cream: :shaved_ice: :birthday: :cake: :cookie: :chocolate_bar: :candy: :lollipop: :honey_pot: :apple: :green_apple: :tangerine: :lemon: :cherries: :grapes: :watermelon: :strawberry: :peach: :melon: :banana: :pear: :pineapple: :sweet_potato: :eggplant: :tomato: :corn: Places :house: :house_with_garden: :school: :office: :post_office: :hospital: :bank: :convenience_store: :love_hotel: :hotel: :wedding: :church: :department_store: :european_post_office: :city_sunrise: :city_sunset: :japanese_castle: :european_castle: :tent: :factory: :tokyo_tower: :japan: :mount_fuji: :sunrise_over_mountains: :sunrise: :stars: :statue_of_liberty: :bridge_at_night: :carousel_horse: :rainbow: :ferris_wheel: :fountain: :roller_coaster: :ship: :speedboat: :boat: :sailboat: :rowboat: :anchor: :rocket: :airplane: :helicopter: :steam_locomotive: :tram: :mountain_railway: :bike: :aerial_tramway: :suspension_railway: :mountain_cableway: :tractor: :blue_car: :oncoming_automobile: :car: :red_car: :taxi: :oncoming_taxi: :articulated_lorry: :bus: :oncoming_bus: :rotating_light: :police_car: :oncoming_police_car: :fire_engine: :ambulance: :minibus: :truck: :train: :station: :train2: :bullettrain_front: :bullettrain_side: :light_rail: :monorail: :railway_car: :trolleybus: :ticket: :fuelpump: :vertical_traffic_light: :traffic_light: :warning: :construction: :beginner: :atm: :slot_machine: :busstop: :barber: :hotsprings: :checkered_flag: :crossed_flags: :izakaya_lantern: :moyai: :circus_tent: :performing_arts: :round_pushpin: :triangular_flag_on_post: :jp: :kr: :cn: :us: :fr: :es: :it: :ru: :gb: :uk: :de: Symbols :one: :two: :three: :four: :five: :six: :seven: :eight: :nine: :keycap_ten: :1234: :zero: :hash: :symbols: :arrow_backward: :arrow_down: :arrow_forward: :arrow_left: :capital_abcd: :abcd: :abc: :arrow_lower_left: :arrow_lower_right: :arrow_right: :arrow_up: :arrow_upper_left: :arrow_upper_right: :arrow_double_down: :arrow_double_up: :arrow_down_small: :arrow_heading_down: :arrow_heading_up: :leftwards_arrow_with_hook: :arrow_right_hook: :left_right_arrow: :arrow_up_down: :arrow_up_small: :arrows_clockwise: :arrows_counterclockwise: :rewind: :fast_forward: :information_source: :ok: :twisted_rightwards_arrows: :repeat: :repeat_one: :new: :top: :up: :cool: :free: :ng: :cinema: :koko: :signal_strength: :u5272: :u5408: :u55b6: :u6307: :u6708: :u6709: :u6e80: :u7121: :u7533: :u7a7a: :u7981: :sa: :restroom: :mens: :womens: :baby_symbol: :no_smoking: :parking: :wheelchair: :metro: :baggage_claim: :accept: :wc: :potable_water: :put_litter_in_its_place: :secret: :congratulations: :m: :passport_control: :left_luggage: :customs: :ideograph_advantage: :cl: :sos: :id: :no_entry_sign: :underage: :no_mobile_phones: :do_not_litter: :non-potable_water: :no_bicycles: :no_pedestrians: :children_crossing: :no_entry: :eight_spoked_asterisk: :eight_pointed_black_star: :heart_decoration: :vs: :vibration_mode: :mobile_phone_off: :chart: :currency_exchange: :aries: :taurus: :gemini: :cancer: :leo: :virgo: :libra: :scorpius: :sagittarius: :capricorn: :aquarius: :pisces: :ophiuchus: :six_pointed_star: :negative_squared_cross_mark: :a: :b: :ab: :o2: :diamond_shape_with_a_dot_inside: :recycle: :end: :on: :soon: :clock1: :clock130: :clock10: :clock1030: :clock11: :clock1130: :clock12: :clock1230: :clock2: :clock230: :clock3: :clock330: :clock4: :clock430: :clock5: :clock530: :clock6: :clock630: :clock7: :clock730: :clock8: :clock830: :clock9: :clock930: :heavy_dollar_sign: :copyright: :registered: :tm: :x: :heavy_exclamation_mark: :bangbang: :interrobang: :o: :heavy_multiplication_x: :heavy_plus_sign: :heavy_minus_sign: :heavy_division_sign: :white_flower: :100: :heavy_check_mark: :ballot_box_with_check: :radio_button: :link: :curly_loop: :wavy_dash: :part_alternation_mark: :trident: :black_square: :black_square: :white_square: :white_square: :white_check_mark: :black_square_button: :white_square_button: :black_circle: :white_circle: :red_circle: :large_blue_circle: :large_blue_diamond: :large_orange_diamond: :small_blue_diamond: :small_orange_diamond: :small_red_triangle: :small_red_triangle_down: :shipit:","title":"Emoji"},{"location":"Contribute/HowToContribute/","text":"","title":"HowToContribute"},{"location":"DataStructures/Basics/Stack/","text":"Stack Element deleted from the set is the one most recently inserted; Stack implements last-in, first out or LIFO policy You can use array to implement Stack supported operations The INSERT operation on a stack is often called PUSH, and the DELETE operation, which does not take an argument, is often called POP. 1. PUSH() 2. POP() 3. EMPTY()","title":"Stack"},{"location":"DataStructures/Basics/Stack/#stack","text":"Element deleted from the set is the one most recently inserted; Stack implements last-in, first out or LIFO policy You can use array to implement Stack","title":"Stack"},{"location":"DataStructures/Basics/Stack/#supported-operations","text":"The INSERT operation on a stack is often called PUSH, and the DELETE operation, which does not take an argument, is often called POP.","title":"supported operations"},{"location":"DataStructures/Basics/Stack/#1-push","text":"","title":"1. PUSH()"},{"location":"DataStructures/Basics/Stack/#2-pop","text":"","title":"2. POP()"},{"location":"DataStructures/Basics/Stack/#3-empty","text":"","title":"3. EMPTY()"},{"location":"DataStructures/HashTables/HashFunctions/","text":"Hash Function A hash function is any function that can be used to map data of arbitrary size onto data of a fixed size. Hash Functions 1. DJB2 this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c. another version of this algorithm (now favored by bernstein) uses xor: hash(i) = hash(i-1) * 33 ^ str[i]; the magic of number 33 (why it works better than many other constants, prime or not) has never adequately explained 1 2 3 4 5 6 7 8 9 10 unsigned long long djb2 ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = ( hash << 5 ) + hash + c ; } return hash ; } 2. sdbm this algorithm was created for sdbm (a public-domain reimplementation of ndbm) database library. it was found to do well in scrambling bits, causing better distribution of the keys and fewer splits. it also happens to be a good general hashing function with good distribution. the actual function is hash(i) = hash(i - 1) * 65599 + str[i];; what is included below is faster version used in gawk. (there iseven a faster, duff's device version) the magic constant 65599 was picked out of thin air while experimenting with different constants, and turns out to be a prime. this is one of the algorithms used in berkeley db (see sleepy cat) and else where 1 2 3 4 5 6 7 8 9 10 unsigned long long sdbm ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = c + ( hash << 6 ) + ( hash << 16 ) - hash ; } return hash ; } 3. lose lose This hash function appeared in K&R (1st ed) but at least the reader was warned: \"This is not the best possible algorithm, but it has the merit of extreme simplicity\". This is an understatement; It is a terrible hashing algorithm, and it could have been much better without scarificing its \"extreme simplicity.\" Many C programmers use this function without actually testing it, or checking something like Knuth's Sorting and searching, so it stuck. It is now found mixed with other respectable code, eg.cnews. Warning Don't use this algorithm, it's terrible. 1 2 3 4 5 6 7 8 9 10 unsigned long long loseLose ( char * str ) { unsigned long long hash = 0 ; int c ; while (( c = * ( str ++ ))) { hash += c ; } return hash ; }","title":"Hash Functions"},{"location":"DataStructures/HashTables/HashFunctions/#hash-function","text":"A hash function is any function that can be used to map data of arbitrary size onto data of a fixed size.","title":"Hash Function"},{"location":"DataStructures/HashTables/HashFunctions/#hash-functions","text":"","title":"Hash Functions"},{"location":"DataStructures/HashTables/HashFunctions/#1-djb2","text":"this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c. another version of this algorithm (now favored by bernstein) uses xor: hash(i) = hash(i-1) * 33 ^ str[i]; the magic of number 33 (why it works better than many other constants, prime or not) has never adequately explained 1 2 3 4 5 6 7 8 9 10 unsigned long long djb2 ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = ( hash << 5 ) + hash + c ; } return hash ; }","title":"1. DJB2"},{"location":"DataStructures/HashTables/HashFunctions/#2-sdbm","text":"this algorithm was created for sdbm (a public-domain reimplementation of ndbm) database library. it was found to do well in scrambling bits, causing better distribution of the keys and fewer splits. it also happens to be a good general hashing function with good distribution. the actual function is hash(i) = hash(i - 1) * 65599 + str[i];; what is included below is faster version used in gawk. (there iseven a faster, duff's device version) the magic constant 65599 was picked out of thin air while experimenting with different constants, and turns out to be a prime. this is one of the algorithms used in berkeley db (see sleepy cat) and else where 1 2 3 4 5 6 7 8 9 10 unsigned long long sdbm ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = c + ( hash << 6 ) + ( hash << 16 ) - hash ; } return hash ; }","title":"2. sdbm"},{"location":"DataStructures/HashTables/HashFunctions/#3-lose-lose","text":"This hash function appeared in K&R (1st ed) but at least the reader was warned: \"This is not the best possible algorithm, but it has the merit of extreme simplicity\". This is an understatement; It is a terrible hashing algorithm, and it could have been much better without scarificing its \"extreme simplicity.\" Many C programmers use this function without actually testing it, or checking something like Knuth's Sorting and searching, so it stuck. It is now found mixed with other respectable code, eg.cnews. Warning Don't use this algorithm, it's terrible. 1 2 3 4 5 6 7 8 9 10 unsigned long long loseLose ( char * str ) { unsigned long long hash = 0 ; int c ; while (( c = * ( str ++ ))) { hash += c ; } return hash ; }","title":"3. lose lose"},{"location":"DataStructures/HashTables/Preface/","text":"Preface Many applications require a dynamic set that supports only the dictionary operations. A Hash Table is an effective data structure for implementing dictionaries. A hash table typically uses an array of size proportional to the number of keys actually stored. Hash functions Instead of using the key as an array index directly, the array index is computed from the key Dealing with collisions Collision: two keys hash to the same slot. Since a hash table uses array of size relatively small to the number of possible keys, there is a chance to collisions in which more than one key maps to the same array index Chaining OpenAddressing PerfectHashing OPERATIONS average worst average worst average worst INSERT $O(1)$ - - SEARCH $O(n/m)$ $O(n)$ $O(1)$ $O(1)$ DELETE $O(1)$ - - 1. Chaining In Chaining, we place all the elements that hash to the same slot in to the same linked llist 2. Open Addressing Resolve Collisions with iterative hashing Perfect Hashing Perfect Hasing uses second level Hashtable that has no collision. perfect hashing can support searches in $O(1)\\ wosrt-case$ time, when the set is static(!= dynamic)","title":"Preface"},{"location":"DataStructures/HashTables/Preface/#preface","text":"Many applications require a dynamic set that supports only the dictionary operations. A Hash Table is an effective data structure for implementing dictionaries. A hash table typically uses an array of size proportional to the number of keys actually stored.","title":"Preface"},{"location":"DataStructures/HashTables/Preface/#hash-functions","text":"Instead of using the key as an array index directly, the array index is computed from the key","title":"Hash functions"},{"location":"DataStructures/HashTables/Preface/#dealing-with-collisions","text":"Collision: two keys hash to the same slot. Since a hash table uses array of size relatively small to the number of possible keys, there is a chance to collisions in which more than one key maps to the same array index Chaining OpenAddressing PerfectHashing OPERATIONS average worst average worst average worst INSERT $O(1)$ - - SEARCH $O(n/m)$ $O(n)$ $O(1)$ $O(1)$ DELETE $O(1)$ - -","title":"Dealing with collisions"},{"location":"DataStructures/HashTables/Preface/#1-chaining","text":"In Chaining, we place all the elements that hash to the same slot in to the same linked llist","title":"1. Chaining"},{"location":"DataStructures/HashTables/Preface/#2-open-addressing","text":"Resolve Collisions with iterative hashing","title":"2. Open Addressing"},{"location":"DataStructures/HashTables/Preface/#perfect-hashing","text":"Perfect Hasing uses second level Hashtable that has no collision. perfect hashing can support searches in $O(1)\\ wosrt-case$ time, when the set is static(!= dynamic)","title":"Perfect Hashing"},{"location":"Language/Class/","text":"Class C++ classes are a tool for creating new types that can be used conveniently as builtin types The Fundamental idea in defining a new type is to separate the details of the implementation from the properties essential to the correc use of it Brief Summary of classes A class is user-defined type A class consists of a set of members. The most common kinds of members are data members and member functions. Member functions can define the meaning of initialization, copy, move, and cleanup Members are accessed using . (dot) for objects and -> (arrow) for pointers. Operators, such as, + , ! , and [] , can be defined for a class A class is a namespace containing its members The public members provide the class's interface and the private members provide implementation details A struct is a class where members are by default public Class Basics class example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class X { private : // the representation (implementation) is private int m ; public : // the user interface is public X ( int i = 0 ) : m { i } {} //a constructor (initialize the data member m) int mf ( int i ) { // a member function int old = m ; m = i ; //set a new value return old ; // return the old value } }; X var { 7 }; // a variable of type X, initialized to 7 int user ( X var , X * ptr ) { int x = var . mf ( 7 ); // access using . int y = ptr -> mf ( 9 ); // access using -> int z = var . m ; // error: cannot acces private member } 1. Member functions Functions declared within a class definition are called member functions 2. Default copying a class object can be initialized with a copy of an obejct of its class 1 2 UserClass c1 = c0 ; // initialization by copy UserClass c2 { d1 }; // initialization by copy 3. Access Control class is consist of two parts private part: can be used only by member functions , public part : interface to objects of class 4. class and struct a struct is a class in which members are by default public struct S{}; is simply short hand for class S{public: }; 5. Constructors a constructor is recognized by having the same name as the class it self. programmers can declare a function with the explicit purpose of initializing objects. 1 2 3 4 5 6 7 8 9 10 11 12 class Date { int d , m , y ; public : Date ( int dd , int mm , int yy ); // constructor } Date today = Date ( 23 , 6 , 1983 ); // OK Date xmas ( 25 , 12 , 1990 ); // OK -> abbreviated form Date my_birthday ; //error: initializer missing Date release1_0 ( 10 , 12 ) //error: third argument missing Date today = Date { 23 , 6 , 1982 } // good! I recommend the {} notation over the () notation for initializing, because it is explicit about what is being done we could use default values directly as default arguments 1 2 3 4 5 class Date { int d , m , y ; public : Date ( int dd = today . d , int mm = today . m , int yy = today . y ); // constructor }","title":"Class"},{"location":"Language/Class/#class","text":"C++ classes are a tool for creating new types that can be used conveniently as builtin types The Fundamental idea in defining a new type is to separate the details of the implementation from the properties essential to the correc use of it","title":"Class"},{"location":"Language/Class/#brief-summary-of-classes","text":"A class is user-defined type A class consists of a set of members. The most common kinds of members are data members and member functions. Member functions can define the meaning of initialization, copy, move, and cleanup Members are accessed using . (dot) for objects and -> (arrow) for pointers. Operators, such as, + , ! , and [] , can be defined for a class A class is a namespace containing its members The public members provide the class's interface and the private members provide implementation details A struct is a class where members are by default public","title":"Brief Summary of classes"},{"location":"Language/Class/#class-basics","text":"","title":"Class Basics"},{"location":"Language/Class/#class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class X { private : // the representation (implementation) is private int m ; public : // the user interface is public X ( int i = 0 ) : m { i } {} //a constructor (initialize the data member m) int mf ( int i ) { // a member function int old = m ; m = i ; //set a new value return old ; // return the old value } }; X var { 7 }; // a variable of type X, initialized to 7 int user ( X var , X * ptr ) { int x = var . mf ( 7 ); // access using . int y = ptr -> mf ( 9 ); // access using -> int z = var . m ; // error: cannot acces private member }","title":"class example"},{"location":"Language/Class/#1-member-functions","text":"Functions declared within a class definition are called member functions","title":"1. Member functions"},{"location":"Language/Class/#2-default-copying","text":"a class object can be initialized with a copy of an obejct of its class 1 2 UserClass c1 = c0 ; // initialization by copy UserClass c2 { d1 }; // initialization by copy","title":"2. Default copying"},{"location":"Language/Class/#3-access-control","text":"class is consist of two parts private part: can be used only by member functions , public part : interface to objects of class","title":"3. Access Control"},{"location":"Language/Class/#4-class-and-struct","text":"a struct is a class in which members are by default public struct S{}; is simply short hand for class S{public: };","title":"4. class and struct"},{"location":"Language/Class/#5-constructors","text":"a constructor is recognized by having the same name as the class it self. programmers can declare a function with the explicit purpose of initializing objects. 1 2 3 4 5 6 7 8 9 10 11 12 class Date { int d , m , y ; public : Date ( int dd , int mm , int yy ); // constructor } Date today = Date ( 23 , 6 , 1983 ); // OK Date xmas ( 25 , 12 , 1990 ); // OK -> abbreviated form Date my_birthday ; //error: initializer missing Date release1_0 ( 10 , 12 ) //error: third argument missing Date today = Date { 23 , 6 , 1982 } // good! I recommend the {} notation over the () notation for initializing, because it is explicit about what is being done we could use default values directly as default arguments 1 2 3 4 5 class Date { int d , m , y ; public : Date ( int dd = today . d , int mm = today . m , int yy = today . y ); // constructor }","title":"5. Constructors"},{"location":"Language/Keywords/","text":"Aliases Aliases are used when we want to insulate our code from details of the underlying machine. - note that naming a type after its representation than its purpose is not neccessarily a good idea. 1. typedef 1 2 cpp typedef double decimal_places ; // is equivalent to \"using decimal_places = double;\" 2. using the using keyword can also be used to introduce a template alias. 1 2 template < typename T > using Vector = std :: vector < T , my_allocator < T >> but we cannot apply type specifiers, such as unsigned, to an alias. 1 2 3 using Char = char ; using Uchar = unsigned Char ; //error using Uchar = unsigned char ; // ok","title":"Keywords"},{"location":"Language/Keywords/#aliases","text":"Aliases are used when we want to insulate our code from details of the underlying machine. - note that naming a type after its representation than its purpose is not neccessarily a good idea.","title":"Aliases"},{"location":"Language/Keywords/#1-typedef","text":"1 2 cpp typedef double decimal_places ; // is equivalent to \"using decimal_places = double;\"","title":"1. typedef"},{"location":"Language/Keywords/#2-using","text":"the using keyword can also be used to introduce a template alias. 1 2 template < typename T > using Vector = std :: vector < T , my_allocator < T >> but we cannot apply type specifiers, such as unsigned, to an alias. 1 2 3 using Char = char ; using Uchar = unsigned Char ; //error using Uchar = unsigned char ; // ok","title":"2. using"},{"location":"Language/Preface/","text":"Why C++? What You Should Know Before.. you should be able to write C++ programs using components such as IOstreams and containers from C++ STL. You Should be also be familiar with the basic features of \"Modern C++\", such as auto, decltype, move semantics, and lambdas. c++17 modern C++ We will use number of these new features of modern C++ 1. C++11 Variadic templates Alias templates Move semantics, rvalue references, and perfect forwarding Standard type traits 2. C++14 Variable templates Generic Lambdas 3. C++17 Class template argument deduction Compile-time if Fold expressions Style Guide 1. the order of constant qualifier. What is in front of const qualifier is always a constant 1 2 int const MAX_SIZE = 100 ; // the int is constant int * const P ; // the pointer cannot change, but int value can; 1 2 const int MAX_SIZE = 100 ; const int * P ; // you can not find what's constant value; reason1. easy to know what's constant. it's always what is in front of the const qualifier reason2. syntatical substitution principle. consider following example 1 2 3 4 5 6 7 typedef char * CHARS ; typedef CHARS const CPTR ; // constant pointer to chars // => typedef char * const CPTR ; using CHARS = char * : using CPTR = CHARS const ; // constant pointer to chars // => using CPTR = char * const ; The meaning of the second declaration is preseved when we textually replace CHARS with what it stands for; How ever if you write const before the type it qualifies. textually 1 2 3 typedef char * CHARS ; typedef const CHARS CTPR ; //const pointer to chars; // => typedef const char* CTPR // pointer to constant chars; footnote: note that typedef defines a \"type alias\" rather than a new type 1 2 3 4 typedef int newInt ; int i = 29 ; newInt j = 1999 ; i = j ; // OK 2. put the space between the & and the parameter name; by doing this, we emphasize the separation between the parameter type and the parameter name. 1 void foo ( int const & x ); 3. avoid declaring multiple entities in this way!. 1 char * a , b ; according to the rules inherited from C, a is a pointer but b is an ordinary char ;","title":"Preface"},{"location":"Language/Preface/#why-c","text":"","title":"Why C++?"},{"location":"Language/Preface/#what-you-should-know-before","text":"you should be able to write C++ programs using components such as IOstreams and containers from C++ STL. You Should be also be familiar with the basic features of \"Modern C++\", such as auto, decltype, move semantics, and lambdas. c++17","title":"What You Should Know Before.."},{"location":"Language/Preface/#modern-c","text":"We will use number of these new features of modern C++","title":"modern C++"},{"location":"Language/Preface/#1-c11","text":"Variadic templates Alias templates Move semantics, rvalue references, and perfect forwarding Standard type traits","title":"1. C++11"},{"location":"Language/Preface/#2-c14","text":"Variable templates Generic Lambdas","title":"2. C++14"},{"location":"Language/Preface/#3-c17","text":"Class template argument deduction Compile-time if Fold expressions","title":"3. C++17"},{"location":"Language/Preface/#style-guide","text":"","title":"Style Guide"},{"location":"Language/Preface/#1-the-order-of-constant-qualifier","text":"What is in front of const qualifier is always a constant 1 2 int const MAX_SIZE = 100 ; // the int is constant int * const P ; // the pointer cannot change, but int value can; 1 2 const int MAX_SIZE = 100 ; const int * P ; // you can not find what's constant value; reason1. easy to know what's constant. it's always what is in front of the const qualifier reason2. syntatical substitution principle. consider following example 1 2 3 4 5 6 7 typedef char * CHARS ; typedef CHARS const CPTR ; // constant pointer to chars // => typedef char * const CPTR ; using CHARS = char * : using CPTR = CHARS const ; // constant pointer to chars // => using CPTR = char * const ; The meaning of the second declaration is preseved when we textually replace CHARS with what it stands for; How ever if you write const before the type it qualifies. textually 1 2 3 typedef char * CHARS ; typedef const CHARS CTPR ; //const pointer to chars; // => typedef const char* CTPR // pointer to constant chars; footnote: note that typedef defines a \"type alias\" rather than a new type 1 2 3 4 typedef int newInt ; int i = 29 ; newInt j = 1999 ; i = j ; // OK","title":"1. the order of constant qualifier."},{"location":"Language/Preface/#2-put-the-space-between-the-amp-and-the-parameter-name","text":"by doing this, we emphasize the separation between the parameter type and the parameter name. 1 void foo ( int const & x );","title":"2. put the space between the &amp; and the parameter name;"},{"location":"Language/Preface/#3-avoid-declaring-multiple-entities-in-this-way","text":"1 char * a , b ; according to the rules inherited from C, a is a pointer but b is an ordinary char ;","title":"3. avoid declaring multiple entities in this way!."}]}