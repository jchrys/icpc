{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"THIS SITE IS UNDER CONSTRUCTION Welcome to ICPC.NINJA SHARE & GET useful problem solving techniques All Articles in this site is implemented on c++17 Why I created this site? Ipsum nemo veritatis illum nulla veniam. Aut esse blanditiis placeat omnis culpa. Odit iusto repudiandae dolorem molestiae labore. Sed a dolores iusto esse placeat officia Obcaecati corporis perspiciatis sequi consequatur. How I created this site? Dolor eveniet incidunt esse nostrum dolor Cumque totam veniam dolore culpa sapiente Repudiandae velit odit magni commodi quasi? Voluptates officiis ab veniam eos totam Dolorem commodi deleniti unde adipisci nihil How to contribute Dolor vitae soluta praesentium obcaecati minus Enim consequuntur expedita voluptatibus eius dignissimos Praesentium provident commodi natus quisquam amet! Eum illo nisi laboriosam rem veritatis Excepturi sed assumenda libero qui accusamus? emojis","title":"Home"},{"location":"#this-site-is-under-construction","text":"","title":"THIS SITE IS UNDER CONSTRUCTION"},{"location":"#welcome-to-icpcninja","text":"SHARE & GET useful problem solving techniques All Articles in this site is implemented on c++17","title":"Welcome to ICPC.NINJA"},{"location":"#why-i-created-this-site","text":"Ipsum nemo veritatis illum nulla veniam. Aut esse blanditiis placeat omnis culpa. Odit iusto repudiandae dolorem molestiae labore. Sed a dolores iusto esse placeat officia Obcaecati corporis perspiciatis sequi consequatur.","title":"Why I created this site?"},{"location":"#how-i-created-this-site","text":"Dolor eveniet incidunt esse nostrum dolor Cumque totam veniam dolore culpa sapiente Repudiandae velit odit magni commodi quasi? Voluptates officiis ab veniam eos totam Dolorem commodi deleniti unde adipisci nihil","title":"How I created this site?"},{"location":"#how-to-contribute","text":"Dolor vitae soluta praesentium obcaecati minus Enim consequuntur expedita voluptatibus eius dignissimos Praesentium provident commodi natus quisquam amet! Eum illo nisi laboriosam rem veritatis Excepturi sed assumenda libero qui accusamus?","title":"How to contribute"},{"location":"#emojis","text":"","title":"emojis"},{"location":"Algorithms/Graph/Basics/","text":"Graph A graph is consists of nodes and edges Terminologies 1. Connectivity A graph is connected if there is a path between any two nodes. Components: Connected parts of its grpah. Tree: a tree is a connected graph that consists of $n$ nodes and $n-1$ edges. 2. Edge directions A graph is directed if the edges can be traversed in one direction only 3. Edge weights In a weighted graph, each edge is assigned a weight. often interpreted as edge length 4. Neighbors and degrees Two nodes are $neighbors$ or $adjacent$ if there is an edge between them Degree: The degrege of a node is number of its neighbors Indegree: The indegree of a node is the number of edges that end at the node Outdegree: The outdegree of a node is the number of edges that start at the node Regular graph: A graph is regular if the degree of every node is a constant d Complete graph: A graph is complete if the degree of every node is $n-1$ Colorings In a coloring of a graph, each node is assigned a color so that no adjacent nodes have the same color Note It turns out that a graph is bipartite exactly when it does not contain a cycle with an odd number of edges Simplicity A graph is simple if no edge starts and ends at the same node(loop), and there are no multiple edges between two nodes. Graph representation There are several ways to represent graphs in algorithms. The choice of a data structure depends on the size of graph and the way the algorithm processes it 1. Adjacency list representation In the adjacency list representation, each node x in the graph is assigned an adjacency list that consists of nodes to which there is an edge from x - we can efficiently find the nodes to which we can move from a given node through an edge 2. Adjacency matrix representation An adjacency matrix is two dimensional array that indicates which edges the graph contains. we can efficiently check from an adjacency matrix if there is an edge between two nodes. 3. Edge list representation An edge list contains all edges of a graph in some order. This is convenient way to represent a graph if the algorithm proesses all edges of the graph and it is not needed to find edges that start at a given node.","title":"Basics"},{"location":"Algorithms/Graph/Basics/#graph","text":"A graph is consists of nodes and edges","title":"Graph"},{"location":"Algorithms/Graph/Basics/#terminologies","text":"","title":"Terminologies"},{"location":"Algorithms/Graph/Basics/#1-connectivity","text":"A graph is connected if there is a path between any two nodes. Components: Connected parts of its grpah. Tree: a tree is a connected graph that consists of $n$ nodes and $n-1$ edges.","title":"1. Connectivity"},{"location":"Algorithms/Graph/Basics/#2-edge-directions","text":"A graph is directed if the edges can be traversed in one direction only","title":"2. Edge directions"},{"location":"Algorithms/Graph/Basics/#3-edge-weights","text":"In a weighted graph, each edge is assigned a weight. often interpreted as edge length","title":"3. Edge weights"},{"location":"Algorithms/Graph/Basics/#4-neighbors-and-degrees","text":"Two nodes are $neighbors$ or $adjacent$ if there is an edge between them Degree: The degrege of a node is number of its neighbors Indegree: The indegree of a node is the number of edges that end at the node Outdegree: The outdegree of a node is the number of edges that start at the node Regular graph: A graph is regular if the degree of every node is a constant d Complete graph: A graph is complete if the degree of every node is $n-1$","title":"4. Neighbors and degrees"},{"location":"Algorithms/Graph/Basics/#colorings","text":"In a coloring of a graph, each node is assigned a color so that no adjacent nodes have the same color Note It turns out that a graph is bipartite exactly when it does not contain a cycle with an odd number of edges","title":"Colorings"},{"location":"Algorithms/Graph/Basics/#simplicity","text":"A graph is simple if no edge starts and ends at the same node(loop), and there are no multiple edges between two nodes.","title":"Simplicity"},{"location":"Algorithms/Graph/Basics/#graph-representation","text":"There are several ways to represent graphs in algorithms. The choice of a data structure depends on the size of graph and the way the algorithm processes it","title":"Graph representation"},{"location":"Algorithms/Graph/Basics/#1-adjacency-list-representation","text":"In the adjacency list representation, each node x in the graph is assigned an adjacency list that consists of nodes to which there is an edge from x - we can efficiently find the nodes to which we can move from a given node through an edge","title":"1. Adjacency list representation"},{"location":"Algorithms/Graph/Basics/#2-adjacency-matrix-representation","text":"An adjacency matrix is two dimensional array that indicates which edges the graph contains. we can efficiently check from an adjacency matrix if there is an edge between two nodes.","title":"2. Adjacency matrix representation"},{"location":"Algorithms/Graph/Basics/#3-edge-list-representation","text":"An edge list contains all edges of a graph in some order. This is convenient way to represent a graph if the algorithm proesses all edges of the graph and it is not needed to find edges that start at a given node.","title":"3. Edge list representation"},{"location":"Algorithms/Graph/GraphTraversal/","text":"Graph Traversal we will cover two fundamental graph algorithms. depth-first search & breadth-first search. BFS vs DFS Both algorithms are given starting node in the graph and they visit all nodes that can be reached from the starting node. The difference in algorithms is the order in which they visit the nodes. Depth-first search Depth-first search ($DFS$) begins at a starting node, and proceeds to all other nodes that are reachable from the starting node using the edges of the graph The algorithm keeps track of visited nodes, so that it processes each node only once implementation using adjacency lists in an array maintain an array visited[N] 1 2 3 4 5 6 7 8 9 10 11 vector < int > adj [ N ]; bool visited [ N ]; void dfs ( int s ) { //starting node s if ( visited [ s ]) return ; visited [ s ] = true ; // process node for ( auto u : adj [ s ]) { dfs ( u ); } } Breadth-first search Breadth-first search($BFS$) visits the nodes in increasing order of their distance from the starting node. Thus, we can calculate the distance from the starting node to all other nodes using $BFS$. Implementation Typical implementation is based on a queue that contains nodes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 queue < int > q ; bool visited [ N ]; int distance [ N ]; visited [ s ] = true ; // starting node s distance [ s ] = 0 ; q . push ( s ); while ( ! q . empty ()) { int cur = q . front (); q . pop (); // process node for ( auto next : adj [ cur ]) { if ( visited [ next ]) continue ; visited [ next ] = true ; distance [ next ] = distance [ cur ] + 1 ; q . push ( next ); } } Applications you can use any of both to check properties of graph but in practice, depth-first search is a better choice, because of ease of implementation 1. Connectivity check A graph is connected if there is a path between any two nodes of the graph Implementation Connected Graph: If a search did not visit all the nodes, we can conclude that the graph is not connected Find all components of Graph: iterating through the nodes and always starting a new depth-first search if the current node does not belong to any component yet 2. Finding cycles Implementation way1: A graph contains a cycle if during a graph traversal, we find a node whose neighbor (other than the previous node in the current path) has already been visited way2(math): if a component contains c nodes and no cycle, it must contain exactly c-1 edges. if there are c or more edges, the component surely contains a cycle 3. Bipartiteness check A graph is bipartite if its nodes can be colored using two colors so that there are no adjacent nodes with the same color Implementation The idea is to color the starting node blue, all its neighbors red, all their neighbors blue, and so on. If at some point of the search we notice that two adjacent nodes have the same color, this means that the graph is not bipartite. Otherwise, the graph is bipartite. Why it works? This algorithm always works, because when there are only two colors available, the color of the starting node in a component determines the colors of all other nodes in the component NP-hard Note that in the general case, it is difficult to find out if the nodes in a graph can be colored using $k$ colors so that no adjacent nodes have the same color. Even when $k=3$, no efficient algorithm is known but the problem is NP-hard","title":"Graph Traversal"},{"location":"Algorithms/Graph/GraphTraversal/#graph-traversal","text":"we will cover two fundamental graph algorithms. depth-first search & breadth-first search. BFS vs DFS Both algorithms are given starting node in the graph and they visit all nodes that can be reached from the starting node. The difference in algorithms is the order in which they visit the nodes.","title":"Graph Traversal"},{"location":"Algorithms/Graph/GraphTraversal/#depth-first-search","text":"Depth-first search ($DFS$) begins at a starting node, and proceeds to all other nodes that are reachable from the starting node using the edges of the graph The algorithm keeps track of visited nodes, so that it processes each node only once","title":"Depth-first search"},{"location":"Algorithms/Graph/GraphTraversal/#implementation","text":"using adjacency lists in an array maintain an array visited[N] 1 2 3 4 5 6 7 8 9 10 11 vector < int > adj [ N ]; bool visited [ N ]; void dfs ( int s ) { //starting node s if ( visited [ s ]) return ; visited [ s ] = true ; // process node for ( auto u : adj [ s ]) { dfs ( u ); } }","title":"implementation"},{"location":"Algorithms/Graph/GraphTraversal/#breadth-first-search","text":"Breadth-first search($BFS$) visits the nodes in increasing order of their distance from the starting node. Thus, we can calculate the distance from the starting node to all other nodes using $BFS$.","title":"Breadth-first search"},{"location":"Algorithms/Graph/GraphTraversal/#implementation_1","text":"Typical implementation is based on a queue that contains nodes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 queue < int > q ; bool visited [ N ]; int distance [ N ]; visited [ s ] = true ; // starting node s distance [ s ] = 0 ; q . push ( s ); while ( ! q . empty ()) { int cur = q . front (); q . pop (); // process node for ( auto next : adj [ cur ]) { if ( visited [ next ]) continue ; visited [ next ] = true ; distance [ next ] = distance [ cur ] + 1 ; q . push ( next ); } }","title":"Implementation"},{"location":"Algorithms/Graph/GraphTraversal/#applications","text":"you can use any of both to check properties of graph but in practice, depth-first search is a better choice, because of ease of implementation","title":"Applications"},{"location":"Algorithms/Graph/GraphTraversal/#1-connectivity-check","text":"A graph is connected if there is a path between any two nodes of the graph","title":"1. Connectivity check"},{"location":"Algorithms/Graph/GraphTraversal/#implementation_2","text":"Connected Graph: If a search did not visit all the nodes, we can conclude that the graph is not connected Find all components of Graph: iterating through the nodes and always starting a new depth-first search if the current node does not belong to any component yet","title":"Implementation"},{"location":"Algorithms/Graph/GraphTraversal/#2-finding-cycles","text":"","title":"2. Finding cycles"},{"location":"Algorithms/Graph/GraphTraversal/#implementation_3","text":"way1: A graph contains a cycle if during a graph traversal, we find a node whose neighbor (other than the previous node in the current path) has already been visited way2(math): if a component contains c nodes and no cycle, it must contain exactly c-1 edges. if there are c or more edges, the component surely contains a cycle","title":"Implementation"},{"location":"Algorithms/Graph/GraphTraversal/#3-bipartiteness-check","text":"A graph is bipartite if its nodes can be colored using two colors so that there are no adjacent nodes with the same color","title":"3. Bipartiteness check"},{"location":"Algorithms/Graph/GraphTraversal/#implementation_4","text":"The idea is to color the starting node blue, all its neighbors red, all their neighbors blue, and so on. If at some point of the search we notice that two adjacent nodes have the same color, this means that the graph is not bipartite. Otherwise, the graph is bipartite. Why it works? This algorithm always works, because when there are only two colors available, the color of the starting node in a component determines the colors of all other nodes in the component NP-hard Note that in the general case, it is difficult to find out if the nodes in a graph can be colored using $k$ colors so that no adjacent nodes have the same color. Even when $k=3$, no efficient algorithm is known but the problem is NP-hard","title":"Implementation"},{"location":"Algorithms/Graph/DFS/FindingCutEdges/","text":"Finding Cut Edges The code below works properly because of the lemma above(first lemma) 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 h [ root ] = 0 par [ v ] = - 1 dfs ( v ): d [ v ] = h [ v ] color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then par [ u ] = v and dfs ( u ) and d [ v ] = min ( d [ v ], d [ u ]) if d [ u ] > h [ v ] then the edge v - u is a cut edge else if u != par [ v ]: then d [ v ] = min ( d [ v ], h [ u ]) color [ v ] = black in this code, h[v] = height of vertex v in the DFS tree and d[v] = min(h[w] where there is at least vertex u in subtree of v in the DFS tree where there is an edge between $u$ and $w$) First lemma will be placed here \u21a9","title":"FindingCutEdges"},{"location":"Algorithms/Graph/DFS/FindingCutEdges/#finding-cut-edges","text":"The code below works properly because of the lemma above(first lemma) 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 h [ root ] = 0 par [ v ] = - 1 dfs ( v ): d [ v ] = h [ v ] color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then par [ u ] = v and dfs ( u ) and d [ v ] = min ( d [ v ], d [ u ]) if d [ u ] > h [ v ] then the edge v - u is a cut edge else if u != par [ v ]: then d [ v ] = min ( d [ v ], h [ u ]) color [ v ] = black in this code, h[v] = height of vertex v in the DFS tree and d[v] = min(h[w] where there is at least vertex u in subtree of v in the DFS tree where there is an edge between $u$ and $w$) First lemma will be placed here \u21a9","title":"Finding Cut Edges"},{"location":"Algorithms/Graph/DFS/Preface/","text":"DFS The most useful graph algorithms are search algorithms. DFS(Depth First Search) is one of them. While running DFS, we assign colors to the vertices (initially white) Algorithm itself is really simple 1 2 3 4 5 6 dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black Black color here is not used, but you can use it sometimes. Time complexity: $O(n + m)$","title":"Preface"},{"location":"Algorithms/Graph/DFS/Preface/#dfs","text":"The most useful graph algorithms are search algorithms. DFS(Depth First Search) is one of them. While running DFS, we assign colors to the vertices (initially white) Algorithm itself is really simple 1 2 3 4 5 6 dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black Black color here is not used, but you can use it sometimes. Time complexity: $O(n + m)$","title":"DFS"},{"location":"Algorithms/Graph/DFS/StartingFinishingTime/","text":"Starting time, finishing time Starting time of a vertex is the time we enter it (the order we enter it) and its finishing time is the time we leave it. Calculating these are easy 1 2 3 4 5 6 7 8 9 TIME = 0 dfs ( v ): st [ v ] = TIME ++ color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black ft [ v ] = TIME # or we can use TIME ++ It is useable in specially data structure problems (convert the tree into an array). Lemma-1 : if we run $dfs(root)$ in a rooted tree, then v is an ancestor of $u$ if and only if $st_v\\leq st_u\\leq ft_u\\leq ft_v$. So, given arrays $st$ and $ft$ we can rebuild the tree.","title":"StartingFinishingTime"},{"location":"Algorithms/Graph/DFS/StartingFinishingTime/#starting-time-finishing-time","text":"Starting time of a vertex is the time we enter it (the order we enter it) and its finishing time is the time we leave it. Calculating these are easy 1 2 3 4 5 6 7 8 9 TIME = 0 dfs ( v ): st [ v ] = TIME ++ color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) color [ v ] = black ft [ v ] = TIME # or we can use TIME ++ It is useable in specially data structure problems (convert the tree into an array). Lemma-1 : if we run $dfs(root)$ in a rooted tree, then v is an ancestor of $u$ if and only if $st_v\\leq st_u\\leq ft_u\\leq ft_v$. So, given arrays $st$ and $ft$ we can rebuild the tree.","title":"Starting time, finishing time"},{"location":"Algorithms/Graph/DFS/Tree/","text":"DFS tree DFS Tree is a rooted tree that is built like this 1 2 3 4 5 6 7 let T be a new tree dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) and par [ u ] = v ( in T ) color [ v ] = black Lemma : There is no cross edges, it means if there is an edge between $V$ and $u$, then $v=par[u]$ or $u=par[v]$","title":"DFSTree"},{"location":"Algorithms/Graph/DFS/Tree/#dfs-tree","text":"DFS Tree is a rooted tree that is built like this 1 2 3 4 5 6 7 let T be a new tree dfs ( v ): color [ v ] = gray for u in adj [ v ]: if color [ u ] == white : then dfs ( u ) and par [ u ] = v ( in T ) color [ v ] = black Lemma : There is no cross edges, it means if there is an edge between $V$ and $u$, then $v=par[u]$ or $u=par[v]$","title":"DFS tree"},{"location":"Algorithms/Sort/BubbleSort/","text":"Bubble Sort Bubble Sort C++ 1 2 3 4 5 6 7 8 9 template < typename It > void BubbleSort ( It begin , It end ) { if ( begin == end ) return ; //return if container is empty for ( It i = end - 1 ; i != begin ; i -- ) { for ( It j = begin ; j != i ; j ++ ) { if ( * j > * ( j + 1 )) swap ( * j , * ( j + 1 )); } } }","title":"BubbleSort"},{"location":"Algorithms/Sort/BubbleSort/#bubble-sort","text":"Bubble Sort","title":"Bubble Sort"},{"location":"Algorithms/Sort/BubbleSort/#c","text":"1 2 3 4 5 6 7 8 9 template < typename It > void BubbleSort ( It begin , It end ) { if ( begin == end ) return ; //return if container is empty for ( It i = end - 1 ; i != begin ; i -- ) { for ( It j = begin ; j != i ; j ++ ) { if ( * j > * ( j + 1 )) swap ( * j , * ( j + 1 )); } } }","title":"C++"},{"location":"Algorithms/Sort/InsertionSort/","text":"Insertion Sort Insertion Sort is very simple algorithm it works exactly like the way you sort a deck of card C++ 1 2 3 4 5 6 7 8 9 10 template < typenme It > // Iterator void insertionSort ( It begin , It end ) { //TODO add comparator if ( begin == end ) return ; // return if container is empty for ( It i = begin ; i != end ; i ++ ) { for ( It j = i ; j != begin ; j -- ) { if ( * ( j - 1 ) < * j ) break ; swap ( * ( j - 1 ), * j ); } } }","title":"InsertionSort"},{"location":"Algorithms/Sort/InsertionSort/#insertion-sort","text":"Insertion Sort is very simple algorithm it works exactly like the way you sort a deck of card","title":"Insertion Sort"},{"location":"Algorithms/Sort/InsertionSort/#c","text":"1 2 3 4 5 6 7 8 9 10 template < typenme It > // Iterator void insertionSort ( It begin , It end ) { //TODO add comparator if ( begin == end ) return ; // return if container is empty for ( It i = begin ; i != end ; i ++ ) { for ( It j = i ; j != begin ; j -- ) { if ( * ( j - 1 ) < * j ) break ; swap ( * ( j - 1 ), * j ); } } }","title":"C++"},{"location":"Contribute/CodeOfConduct/","text":"Code of Conduct Copy & go all codes should be working if you directly copy & paste to compiler. Compatibility with STL all the implementation should work with C++ STL. Example YourVector< int> v; ---snip--- sort(v.begin(), v.end()); // should be working","title":"CodeOfConduct"},{"location":"Contribute/CodeOfConduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"Contribute/CodeOfConduct/#copy-go","text":"all codes should be working if you directly copy & paste to compiler.","title":"Copy &amp; go"},{"location":"Contribute/CodeOfConduct/#compatibility-with-stl","text":"all the implementation should work with C++ STL. Example YourVector< int> v; ---snip--- sort(v.begin(), v.end()); // should be working","title":"Compatibility with STL"},{"location":"Contribute/Emoji/","text":"People :bowtie: :smile: :laughing: :blush: :smiley: :relaxed: :smirk: :heart_eyes: :kissing_heart: :kissing_closed_eyes: :flushed: :relieved: :satisfied: :grin: :wink: :stuck_out_tongue_winking_eye: :stuck_out_tongue_closed_eyes: :grinning: :kissing: :kissing_smiling_eyes: :stuck_out_tongue: :sleeping: :worried: :frowning: :anguished: :open_mouth: :grimacing: :confused: :hushed: :expressionless: :unamused: :sweat_smile: :sweat: :disappointed_relieved: :weary: :pensive: :disappointed: :confounded: :fearful: :cold_sweat: :persevere: :cry: :sob: :joy: :astonished: :scream: :neckbeard: :tired_face: :angry: :rage: :triumph: :sleepy: :yum: :mask: :sunglasses: :dizzy_face: :imp: :smiling_imp: :neutral_face: :no_mouth: :innocent: :alien: :yellow_heart: :blue_heart: :purple_heart: :heart: :green_heart: :broken_heart: :heartbeat: :heartpulse: :two_hearts: :revolving_hearts: :cupid: :sparkling_heart: :sparkles: :star: :star2: :dizzy: :boom: :collision: :anger: :exclamation: :question: :grey_exclamation: :grey_question: :zzz: :dash: :sweat_drops: :notes: :musical_note: :fire: :hankey: :poop: :shit: :+1: :thumbsup: :-1: :thumbsdown: :ok_hand: :punch: :facepunch: :fist: :v: :wave: :hand: :raised_hand: :open_hands: :point_up: :point_down: :point_left: :point_right: :raised_hands: :pray: :point_up_2: :clap: :muscle: :metal: :fu: :walking: :runner: :running: :couple: :family: :two_men_holding_hands: :two_women_holding_hands: :dancer: :dancers: :ok_woman: :no_good: :information_desk_person: :raising_hand: :bride_with_veil: :person_with_pouting_face: :person_frowning: :bow: :couplekiss: :couplekiss: :couple_with_heart: :massage: :haircut: :nail_care: :boy: :girl: :woman: :man: :baby: :older_woman: :older_man: :person_with_blond_hair: :man_with_gua_pi_mao: :man_with_turban: :construction_worker: :cop: :angel: :princess: :smiley_cat: :smile_cat: :heart_eyes_cat: :kissing_cat: :smirk_cat: :scream_cat: :crying_cat_face: :joy_cat: :pouting_cat: :japanese_ogre: :japanese_goblin: :see_no_evil: :hear_no_evil: :speak_no_evil: :guardsman: :skull: :feet: :lips: :kiss: :droplet: :ear: :eyes: :nose: :tongue: :love_letter: :bust_in_silhouette: :busts_in_silhouette: :speech_balloon: :thought_balloon: :feelsgood: :finnadie: :goberserk: :godmode: :hurtrealbad: :rage1: :rage2: :rage3: :rage4: :suspect: :trollface: Nature :sunny: :umbrella: :cloud: :snowflake: :snowman: :zap: :cyclone: :foggy: :ocean: :cat: :dog: :mouse: :hamster: :rabbit: :wolf: :frog: :tiger: :koala: :bear: :pig: :pig_nose: :cow: :boar: :monkey_face: :monkey: :horse: :racehorse: :camel: :sheep: :elephant: :panda_face: :snake: :bird: :baby_chick: :hatched_chick: :hatching_chick: :chicken: :penguin: :turtle: :bug: :honeybee: :ant: :beetle: :snail: :octopus: :tropical_fish: :fish: :whale: :whale2: :dolphin: :cow2: :ram: :rat: :water_buffalo: :tiger2: :rabbit2: :dragon: :goat: :rooster: :dog2: :pig2: :mouse2: :ox: :dragon_face: :blowfish: :crocodile: :dromedary_camel: :leopard: :cat2: :poodle: :paw_prints: :bouquet: :cherry_blossom: :tulip: :four_leaf_clover: :rose: :sunflower: :hibiscus: :maple_leaf: :leaves: :fallen_leaf: :herb: :mushroom: :cactus: :palm_tree: :evergreen_tree: :deciduous_tree: :chestnut: :seedling: :blossom: :ear_of_rice: :shell: :globe_with_meridians: :sun_with_face: :full_moon_with_face: :new_moon_with_face: :new_moon: :waxing_crescent_moon: :first_quarter_moon: :waxing_gibbous_moon: :full_moon: :waning_gibbous_moon: :last_quarter_moon: :waning_crescent_moon: :last_quarter_moon_with_face: :first_quarter_moon_with_face: :moon: :earth_africa: :earth_americas: :earth_asia: :volcano: :milky_way: :partly_sunny: :octocat: :squirrel: Objects :bamboo: :gift_heart: :dolls: :school_satchel: :mortar_board: :flags: :fireworks: :sparkler: :wind_chime: :rice_scene: :jack_o_lantern: :ghost: :santa: :christmas_tree: :gift: :bell: :no_bell: :tanabata_tree: :tada: :confetti_ball: :balloon: :crystal_ball: :cd: :dvd: :floppy_disk: :camera: :video_camera: :movie_camera: :computer: :tv: :iphone: :phone: :telephone: :telephone_receiver: :pager: :fax: :minidisc: :vhs: :sound: :speaker: :mute: :loudspeaker: :mega: :hourglass: :hourglass_flowing_sand: :alarm_clock: :watch: :radio: :satellite: :loop: :mag: :mag_right: :unlock: :lock: :lock_with_ink_pen: :closed_lock_with_key: :key: :bulb: :flashlight: :high_brightness: :low_brightness: :electric_plug: :battery: :calling: :email: :mailbox: :postbox: :bath: :bathtub: :shower: :toilet: :wrench: :nut_and_bolt: :hammer: :seat: :moneybag: :yen: :dollar: :pound: :euro: :credit_card: :money_with_wings: :e-mail: :inbox_tray: :outbox_tray: :envelope: :incoming_envelope: :postal_horn: :mailbox_closed: :mailbox_with_mail: :mailbox_with_no_mail: :door: :smoking: :bomb: :gun: :hocho: :pill: :syringe: :page_facing_up: :page_with_curl: :bookmark_tabs: :bar_chart: :chart_with_upwards_trend: :chart_with_downwards_trend: :scroll: :clipboard: :calendar: :date: :card_index: :file_folder: :open_file_folder: :scissors: :pushpin: :paperclip: :black_nib: :pencil2: :straight_ruler: :triangular_ruler: :closed_book: :green_book: :blue_book: :orange_book: :notebook: :notebook_with_decorative_cover: :ledger: :books: :bookmark: :name_badge: :microscope: :telescope: :newspaper: :football: :basketball: :soccer: :baseball: :tennis: :8ball: :rugby_football: :bowling: :golf: :mountain_bicyclist: :bicyclist: :horse_racing: :snowboarder: :swimmer: :surfer: :ski: :spades: :hearts: :clubs: :diamonds: :gem: :ring: :trophy: :musical_score: :musical_keyboard: :violin: :space_invader: :video_game: :black_joker: :flower_playing_cards: :game_die: :dart: :mahjong: :clapper: :memo: :pencil: :book: :art: :microphone: :headphones: :trumpet: :saxophone: :guitar: :shoe: :sandal: :high_heel: :lipstick: :boot: :shirt: :tshirt: :necktie: :womans_clothes: :dress: :running_shirt_with_sash: :jeans: :kimono: :bikini: :ribbon: :tophat: :crown: :womans_hat: :mans_shoe: :closed_umbrella: :briefcase: :handbag: :pouch: :purse: :eyeglasses: :fishing_pole_and_fish: :coffee: :tea: :sake: :baby_bottle: :beer: :beers: :cocktail: :tropical_drink: :wine_glass: :fork_and_knife: :pizza: :hamburger: :fries: :poultry_leg: :meat_on_bone: :spaghetti: :curry: :fried_shrimp: :bento: :sushi: :fish_cake: :rice_ball: :rice_cracker: :rice: :ramen: :stew: :oden: :dango: :egg: :bread: :doughnut: :custard: :icecream: :ice_cream: :shaved_ice: :birthday: :cake: :cookie: :chocolate_bar: :candy: :lollipop: :honey_pot: :apple: :green_apple: :tangerine: :lemon: :cherries: :grapes: :watermelon: :strawberry: :peach: :melon: :banana: :pear: :pineapple: :sweet_potato: :eggplant: :tomato: :corn: Places :house: :house_with_garden: :school: :office: :post_office: :hospital: :bank: :convenience_store: :love_hotel: :hotel: :wedding: :church: :department_store: :european_post_office: :city_sunrise: :city_sunset: :japanese_castle: :european_castle: :tent: :factory: :tokyo_tower: :japan: :mount_fuji: :sunrise_over_mountains: :sunrise: :stars: :statue_of_liberty: :bridge_at_night: :carousel_horse: :rainbow: :ferris_wheel: :fountain: :roller_coaster: :ship: :speedboat: :boat: :sailboat: :rowboat: :anchor: :rocket: :airplane: :helicopter: :steam_locomotive: :tram: :mountain_railway: :bike: :aerial_tramway: :suspension_railway: :mountain_cableway: :tractor: :blue_car: :oncoming_automobile: :car: :red_car: :taxi: :oncoming_taxi: :articulated_lorry: :bus: :oncoming_bus: :rotating_light: :police_car: :oncoming_police_car: :fire_engine: :ambulance: :minibus: :truck: :train: :station: :train2: :bullettrain_front: :bullettrain_side: :light_rail: :monorail: :railway_car: :trolleybus: :ticket: :fuelpump: :vertical_traffic_light: :traffic_light: :warning: :construction: :beginner: :atm: :slot_machine: :busstop: :barber: :hotsprings: :checkered_flag: :crossed_flags: :izakaya_lantern: :moyai: :circus_tent: :performing_arts: :round_pushpin: :triangular_flag_on_post: :jp: :kr: :cn: :us: :fr: :es: :it: :ru: :gb: :uk: :de: Symbols :one: :two: :three: :four: :five: :six: :seven: :eight: :nine: :keycap_ten: :1234: :zero: :hash: :symbols: :arrow_backward: :arrow_down: :arrow_forward: :arrow_left: :capital_abcd: :abcd: :abc: :arrow_lower_left: :arrow_lower_right: :arrow_right: :arrow_up: :arrow_upper_left: :arrow_upper_right: :arrow_double_down: :arrow_double_up: :arrow_down_small: :arrow_heading_down: :arrow_heading_up: :leftwards_arrow_with_hook: :arrow_right_hook: :left_right_arrow: :arrow_up_down: :arrow_up_small: :arrows_clockwise: :arrows_counterclockwise: :rewind: :fast_forward: :information_source: :ok: :twisted_rightwards_arrows: :repeat: :repeat_one: :new: :top: :up: :cool: :free: :ng: :cinema: :koko: :signal_strength: :u5272: :u5408: :u55b6: :u6307: :u6708: :u6709: :u6e80: :u7121: :u7533: :u7a7a: :u7981: :sa: :restroom: :mens: :womens: :baby_symbol: :no_smoking: :parking: :wheelchair: :metro: :baggage_claim: :accept: :wc: :potable_water: :put_litter_in_its_place: :secret: :congratulations: :m: :passport_control: :left_luggage: :customs: :ideograph_advantage: :cl: :sos: :id: :no_entry_sign: :underage: :no_mobile_phones: :do_not_litter: :non-potable_water: :no_bicycles: :no_pedestrians: :children_crossing: :no_entry: :eight_spoked_asterisk: :eight_pointed_black_star: :heart_decoration: :vs: :vibration_mode: :mobile_phone_off: :chart: :currency_exchange: :aries: :taurus: :gemini: :cancer: :leo: :virgo: :libra: :scorpius: :sagittarius: :capricorn: :aquarius: :pisces: :ophiuchus: :six_pointed_star: :negative_squared_cross_mark: :a: :b: :ab: :o2: :diamond_shape_with_a_dot_inside: :recycle: :end: :on: :soon: :clock1: :clock130: :clock10: :clock1030: :clock11: :clock1130: :clock12: :clock1230: :clock2: :clock230: :clock3: :clock330: :clock4: :clock430: :clock5: :clock530: :clock6: :clock630: :clock7: :clock730: :clock8: :clock830: :clock9: :clock930: :heavy_dollar_sign: :copyright: :registered: :tm: :x: :heavy_exclamation_mark: :bangbang: :interrobang: :o: :heavy_multiplication_x: :heavy_plus_sign: :heavy_minus_sign: :heavy_division_sign: :white_flower: :100: :heavy_check_mark: :ballot_box_with_check: :radio_button: :link: :curly_loop: :wavy_dash: :part_alternation_mark: :trident: :black_square: :black_square: :white_square: :white_square: :white_check_mark: :black_square_button: :white_square_button: :black_circle: :white_circle: :red_circle: :large_blue_circle: :large_blue_diamond: :large_orange_diamond: :small_blue_diamond: :small_orange_diamond: :small_red_triangle: :small_red_triangle_down: :shipit:","title":"Emoji"},{"location":"Contribute/HowToContribute/","text":"How To Contribute This is My first open source project under very active development and is also being used to ship code to everybody on codeforces , AtCoder , HackerRank , LeetCode , BaekJoonOnlineJudge and so on. I'm still working out to make contributing to this project as easy and transparent as possible, but I'm not quite there yet. Hopefully this document makes the process for contributing clear and answers some quiestions that you may have. Code of Conduct I adopted a Code of Conduct that i expect project participants to adhere to. You can see full document of Code Of Conduct . 1. copy & pastable All the codes in this site are ready-to-be-compiled that means you could just copy & paste it to see it works. 2. Compatibility Data Structure implementations should be compatible with C++ STL. ex) sort(Your_implementation.begin(), Your_implementation.end()) should work. Use template for your convinience there's a template for contribute","title":"HowToContribute"},{"location":"Contribute/HowToContribute/#how-to-contribute","text":"This is My first open source project under very active development and is also being used to ship code to everybody on codeforces , AtCoder , HackerRank , LeetCode , BaekJoonOnlineJudge and so on. I'm still working out to make contributing to this project as easy and transparent as possible, but I'm not quite there yet. Hopefully this document makes the process for contributing clear and answers some quiestions that you may have.","title":"How To Contribute"},{"location":"Contribute/HowToContribute/#code-of-conduct","text":"I adopted a Code of Conduct that i expect project participants to adhere to. You can see full document of Code Of Conduct .","title":"Code of Conduct"},{"location":"Contribute/HowToContribute/#1-copy-pastable","text":"All the codes in this site are ready-to-be-compiled that means you could just copy & paste it to see it works.","title":"1. copy &amp; pastable"},{"location":"Contribute/HowToContribute/#2-compatibility","text":"Data Structure implementations should be compatible with C++ STL. ex) sort(Your_implementation.begin(), Your_implementation.end()) should work.","title":"2. Compatibility"},{"location":"Contribute/HowToContribute/#use-template-for-your-convinience","text":"there's a template for contribute","title":"Use template for your convinience"},{"location":"Contribute/Template/","text":"Vector Brief explanation. Operations & time complexity Methods RunningTime push_back(val) O(1) pop() O(1) empty() O(1) you can use table generator Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cstido> #include <iostream> template < typename T > class Vector { //use TitleCase for DataStructure implementation --- snip --- } int main () { //few lines of code to test your implementation Vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { v . push_back ( rand () % 100 ); } sort ( v . begin (), v . end ()) for ( auto x : v ) { cout << x << ' ' ; } } keep your implementation is self-contained. Related Problems title of easy problem Some hard problem Lily want a phone add difficulty information(optional) Related Topics Stack Analysis (Optional) You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $ Contributers (Optional) 07.12.2019 contributer1 07.14.2019 typo correction contributer2 07.15.2019 add new section \"Analysis\" contributer3 07.18.2019 fix bugs in \"implementation\" contributer4 07.19.2019 improved performance \"implementation\" contributer5 07.23.2019 refactoring \"implementation\" contributer6 08.02.2019 add related problems contributer7","title":"Template"},{"location":"Contribute/Template/#vector","text":"Brief explanation.","title":"Vector"},{"location":"Contribute/Template/#operations-time-complexity","text":"Methods RunningTime push_back(val) O(1) pop() O(1) empty() O(1) you can use table generator","title":"Operations &amp; time complexity"},{"location":"Contribute/Template/#implementation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cstido> #include <iostream> template < typename T > class Vector { //use TitleCase for DataStructure implementation --- snip --- } int main () { //few lines of code to test your implementation Vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { v . push_back ( rand () % 100 ); } sort ( v . begin (), v . end ()) for ( auto x : v ) { cout << x << ' ' ; } } keep your implementation is self-contained.","title":"Implementation"},{"location":"Contribute/Template/#related-problems","text":"title of easy problem Some hard problem Lily want a phone add difficulty information(optional)","title":"Related Problems"},{"location":"Contribute/Template/#related-topics","text":"Stack","title":"Related Topics"},{"location":"Contribute/Template/#analysis-optional","text":"You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $","title":"Analysis (Optional)"},{"location":"Contribute/Template/#contributers-optional","text":"07.12.2019 contributer1 07.14.2019 typo correction contributer2 07.15.2019 add new section \"Analysis\" contributer3 07.18.2019 fix bugs in \"implementation\" contributer4 07.19.2019 improved performance \"implementation\" contributer5 07.23.2019 refactoring \"implementation\" contributer6 08.02.2019 add related problems contributer7","title":"Contributers (Optional)"},{"location":"DataStructures/HashTables/HashFunctions/","text":"Hash Function A hash function is any function that can be used to map data of arbitrary size onto data of a fixed size. Hash Functions 1. DJB2 this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c. another version of this algorithm (now favored by bernstein) uses xor: hash(i) = hash(i-1) * 33 ^ str[i]; the magic of number 33 (why it works better than many other constants, prime or not) has never adequately explained 1 2 3 4 5 6 7 8 9 10 unsigned long long djb2 ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = ( hash << 5 ) + hash + c ; } return hash ; } 2. sdbm this algorithm was created for sdbm (a public-domain reimplementation of ndbm) database library. it was found to do well in scrambling bits, causing better distribution of the keys and fewer splits. it also happens to be a good general hashing function with good distribution. the actual function is hash(i) = hash(i - 1) * 65599 + str[i];; what is included below is faster version used in gawk. (there iseven a faster, duff's device version) the magic constant 65599 was picked out of thin air while experimenting with different constants, and turns out to be a prime. this is one of the algorithms used in berkeley db (see sleepy cat) and else where 1 2 3 4 5 6 7 8 9 10 unsigned long long sdbm ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = c + ( hash << 6 ) + ( hash << 16 ) - hash ; } return hash ; } 3. lose lose This hash function appeared in K&R (1st ed) but at least the reader was warned: \"This is not the best possible algorithm, but it has the merit of extreme simplicity\". This is an understatement; It is a terrible hashing algorithm, and it could have been much better without scarificing its \"extreme simplicity.\" Many C programmers use this function without actually testing it, or checking something like Knuth's Sorting and searching, so it stuck. It is now found mixed with other respectable code, eg.cnews. Warning Don't use this algorithm, it's terrible. 1 2 3 4 5 6 7 8 9 10 unsigned long long loseLose ( char * str ) { unsigned long long hash = 0 ; int c ; while (( c = * ( str ++ ))) { hash += c ; } return hash ; }","title":"Hash Functions"},{"location":"DataStructures/HashTables/HashFunctions/#hash-function","text":"A hash function is any function that can be used to map data of arbitrary size onto data of a fixed size.","title":"Hash Function"},{"location":"DataStructures/HashTables/HashFunctions/#hash-functions","text":"","title":"Hash Functions"},{"location":"DataStructures/HashTables/HashFunctions/#1-djb2","text":"this algorithm (k=33) was first reported by dan bernstein many years ago in comp.lang.c. another version of this algorithm (now favored by bernstein) uses xor: hash(i) = hash(i-1) * 33 ^ str[i]; the magic of number 33 (why it works better than many other constants, prime or not) has never adequately explained 1 2 3 4 5 6 7 8 9 10 unsigned long long djb2 ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = ( hash << 5 ) + hash + c ; } return hash ; }","title":"1. DJB2"},{"location":"DataStructures/HashTables/HashFunctions/#2-sdbm","text":"this algorithm was created for sdbm (a public-domain reimplementation of ndbm) database library. it was found to do well in scrambling bits, causing better distribution of the keys and fewer splits. it also happens to be a good general hashing function with good distribution. the actual function is hash(i) = hash(i - 1) * 65599 + str[i];; what is included below is faster version used in gawk. (there iseven a faster, duff's device version) the magic constant 65599 was picked out of thin air while experimenting with different constants, and turns out to be a prime. this is one of the algorithms used in berkeley db (see sleepy cat) and else where 1 2 3 4 5 6 7 8 9 10 unsigned long long sdbm ( char * str ) { unsigned long long hash = 5381 ; int c ; while (( c = * ( str ++ ))) { hash = c + ( hash << 6 ) + ( hash << 16 ) - hash ; } return hash ; }","title":"2. sdbm"},{"location":"DataStructures/HashTables/HashFunctions/#3-lose-lose","text":"This hash function appeared in K&R (1st ed) but at least the reader was warned: \"This is not the best possible algorithm, but it has the merit of extreme simplicity\". This is an understatement; It is a terrible hashing algorithm, and it could have been much better without scarificing its \"extreme simplicity.\" Many C programmers use this function without actually testing it, or checking something like Knuth's Sorting and searching, so it stuck. It is now found mixed with other respectable code, eg.cnews. Warning Don't use this algorithm, it's terrible. 1 2 3 4 5 6 7 8 9 10 unsigned long long loseLose ( char * str ) { unsigned long long hash = 0 ; int c ; while (( c = * ( str ++ ))) { hash += c ; } return hash ; }","title":"3. lose lose"},{"location":"DataStructures/HashTables/Preface/","text":"Preface Many applications require a dynamic set that supports only the dictionary operations. A Hash Table is an effective data structure for implementing dictionaries. A hash table typically uses an array of size proportional to the number of keys actually stored. Hash functions Instead of using the key as an array index directly, the array index is computed from the key Dealing with collisions Collision: two keys hash to the same slot. Since a hash table uses array of size relatively small to the number of possible keys, there is a chance to collisions in which more than one key maps to the same array index Chaining OpenAddressing PerfectHashing OPERATIONS average worst average worst average worst INSERT $O(1)$ - - SEARCH $O(n/m)$ $O(n)$ $O(1)$ $O(1)$ DELETE $O(1)$ - - 1. Chaining In Chaining, we place all the elements that hash to the same slot in to the same linked llist 2. Open Addressing Resolve Collisions with iterative hashing Perfect Hashing Perfect Hasing uses second level Hashtable that has no collision. perfect hashing can support searches in $O(1)\\ wosrt-case$ time, when the set is static(!= dynamic)","title":"Preface"},{"location":"DataStructures/HashTables/Preface/#preface","text":"Many applications require a dynamic set that supports only the dictionary operations. A Hash Table is an effective data structure for implementing dictionaries. A hash table typically uses an array of size proportional to the number of keys actually stored.","title":"Preface"},{"location":"DataStructures/HashTables/Preface/#hash-functions","text":"Instead of using the key as an array index directly, the array index is computed from the key","title":"Hash functions"},{"location":"DataStructures/HashTables/Preface/#dealing-with-collisions","text":"Collision: two keys hash to the same slot. Since a hash table uses array of size relatively small to the number of possible keys, there is a chance to collisions in which more than one key maps to the same array index Chaining OpenAddressing PerfectHashing OPERATIONS average worst average worst average worst INSERT $O(1)$ - - SEARCH $O(n/m)$ $O(n)$ $O(1)$ $O(1)$ DELETE $O(1)$ - -","title":"Dealing with collisions"},{"location":"DataStructures/HashTables/Preface/#1-chaining","text":"In Chaining, we place all the elements that hash to the same slot in to the same linked llist","title":"1. Chaining"},{"location":"DataStructures/HashTables/Preface/#2-open-addressing","text":"Resolve Collisions with iterative hashing","title":"2. Open Addressing"},{"location":"DataStructures/HashTables/Preface/#perfect-hashing","text":"Perfect Hasing uses second level Hashtable that has no collision. perfect hashing can support searches in $O(1)\\ wosrt-case$ time, when the set is static(!= dynamic)","title":"Perfect Hashing"},{"location":"DataStructures/Linear/LinkedList/","text":"LinkedList(Doubly Linked List) A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations. The elements in a linked lists are linked using pointers. Operations & time complexity Member Function Running Time insert_front() $\\Omicron(1)$ insert_back() $\\Omicron(1)$ insert_after() $\\Omicron(1)$ erase $\\Omicron(1)$ search() $\\Omicron(n)$ Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include <bits/stdc++.h> using namespace std ; template < typename T > class LinkedList { struct Node { Node * before ; Node * next ; T data ; Node ( T data ) : before ( 0 ), next ( 0 ), data ( data ){} ~ Node () { delete before ; delete next ; delete data ; } }; Node * tail ; unsigned int _size ; public : Node * head ; LinkedList () : head ( 0 ), tail ( 0 ) {} void insert_front ( T val ) { Node * temp = new Node ( val ); if ( head == 0 ) { head = temp ; tail = temp ; } else { temp -> next = head ; head -> before = temp ; head = temp ; } } void insert_back ( T val ) { Node * temp = new Node ( val ); if ( tail == 0 ) { head = temp ; tail = temp ; } else { temp -> before = tail ; tail -> next = temp ; tail = temp ; } } void insert_after ( Node * node , T val ) { Node * temp = new Node ( val ); if ( temp -> next == 0 ) { tail = temp ; } temp -> next = node -> next ; temp -> next -> before = temp ; node -> next = temp ; temp -> before = node ; } Node * search ( T val ) { //search_from head Node * it = head ; while ( it != 0 && it -> data != val ) it = it -> next ; return it ; } void erase ( Node * node ) { if ( node == 0 ) return ; if ( node -> next == 0 ) { tail = node -> before ; tail -> next = 0 ; } else if ( node -> before == 0 ) { head = node -> next ; head -> before = 0 ; } else { node -> before -> next = node -> next ; node -> next = node -> before ; } delete node ; } void print () { Node * it = head ; while ( it != 0 ) { cout << it -> data << ' ' ; it = it -> next ; } } }; int main () { LinkedList < int > list ; for ( int i = 0 ; i < 100 ; i ++ ) { list . insert_front ( i ); } for ( int i = 0 ; i < 100 ; i ++ ) { list . insert_back ( i ); } for ( int i = 0 ; i < 100 ; i ++ ) { list . insert_after ( list . head -> next , i ); } list . print (); return 0 ; } Related Problems NEED_TO_BE_ADDED Related Topics NOT_YET Analysis (Later..) You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $ Contributers 08.15.2019 jchrys","title":"Linked List"},{"location":"DataStructures/Linear/LinkedList/#linkedlistdoubly-linked-list","text":"A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations. The elements in a linked lists are linked using pointers.","title":"LinkedList(Doubly Linked List)"},{"location":"DataStructures/Linear/LinkedList/#operations-time-complexity","text":"Member Function Running Time insert_front() $\\Omicron(1)$ insert_back() $\\Omicron(1)$ insert_after() $\\Omicron(1)$ erase $\\Omicron(1)$ search() $\\Omicron(n)$","title":"Operations &amp; time complexity"},{"location":"DataStructures/Linear/LinkedList/#implementation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include <bits/stdc++.h> using namespace std ; template < typename T > class LinkedList { struct Node { Node * before ; Node * next ; T data ; Node ( T data ) : before ( 0 ), next ( 0 ), data ( data ){} ~ Node () { delete before ; delete next ; delete data ; } }; Node * tail ; unsigned int _size ; public : Node * head ; LinkedList () : head ( 0 ), tail ( 0 ) {} void insert_front ( T val ) { Node * temp = new Node ( val ); if ( head == 0 ) { head = temp ; tail = temp ; } else { temp -> next = head ; head -> before = temp ; head = temp ; } } void insert_back ( T val ) { Node * temp = new Node ( val ); if ( tail == 0 ) { head = temp ; tail = temp ; } else { temp -> before = tail ; tail -> next = temp ; tail = temp ; } } void insert_after ( Node * node , T val ) { Node * temp = new Node ( val ); if ( temp -> next == 0 ) { tail = temp ; } temp -> next = node -> next ; temp -> next -> before = temp ; node -> next = temp ; temp -> before = node ; } Node * search ( T val ) { //search_from head Node * it = head ; while ( it != 0 && it -> data != val ) it = it -> next ; return it ; } void erase ( Node * node ) { if ( node == 0 ) return ; if ( node -> next == 0 ) { tail = node -> before ; tail -> next = 0 ; } else if ( node -> before == 0 ) { head = node -> next ; head -> before = 0 ; } else { node -> before -> next = node -> next ; node -> next = node -> before ; } delete node ; } void print () { Node * it = head ; while ( it != 0 ) { cout << it -> data << ' ' ; it = it -> next ; } } }; int main () { LinkedList < int > list ; for ( int i = 0 ; i < 100 ; i ++ ) { list . insert_front ( i ); } for ( int i = 0 ; i < 100 ; i ++ ) { list . insert_back ( i ); } for ( int i = 0 ; i < 100 ; i ++ ) { list . insert_after ( list . head -> next , i ); } list . print (); return 0 ; }","title":"Implementation"},{"location":"DataStructures/Linear/LinkedList/#related-problems","text":"NEED_TO_BE_ADDED","title":"Related Problems"},{"location":"DataStructures/Linear/LinkedList/#related-topics","text":"NOT_YET","title":"Related Topics"},{"location":"DataStructures/Linear/LinkedList/#analysis-later","text":"You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $","title":"Analysis (Later..)"},{"location":"DataStructures/Linear/LinkedList/#contributers","text":"08.15.2019 jchrys","title":"Contributers"},{"location":"DataStructures/Linear/Stack/","text":"Stack Element deleted from the set is the one most recently inserted; Stack implements last-in, first out or LIFO policy You can use array to implement Stack supported operations insert, delete, empty, top, size 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 template < typename T > class Stack { public : struct Node { T val ; Node * next ; Node () {}; Node ( T val ) : val ( val ), next ( 0 ){}; }; Node * head ; int _size ; Stack () { head = 0 ; _size = 0 ; } void push ( T val ) { Node * temp = new Node ( val ); if ( head == 0 ) { head = temp ; } else { temp -> next = head ; head = temp ; } _size ++ ; } void pop () { if ( empty ()) return ; Node * temp = head ; head = head -> next ; delete temp ; _size -- ; } bool empty () const { return _size == 0 ; } T top () const { return head -> val ; } int size () const { return _size ; } };","title":"Stack"},{"location":"DataStructures/Linear/Stack/#stack","text":"Element deleted from the set is the one most recently inserted; Stack implements last-in, first out or LIFO policy You can use array to implement Stack","title":"Stack"},{"location":"DataStructures/Linear/Stack/#supported-operations","text":"insert, delete, empty, top, size 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 template < typename T > class Stack { public : struct Node { T val ; Node * next ; Node () {}; Node ( T val ) : val ( val ), next ( 0 ){}; }; Node * head ; int _size ; Stack () { head = 0 ; _size = 0 ; } void push ( T val ) { Node * temp = new Node ( val ); if ( head == 0 ) { head = temp ; } else { temp -> next = head ; head = temp ; } _size ++ ; } void pop () { if ( empty ()) return ; Node * temp = head ; head = head -> next ; delete temp ; _size -- ; } bool empty () const { return _size == 0 ; } T top () const { return head -> val ; } int size () const { return _size ; } };","title":"supported operations"},{"location":"DataStructures/Linear/Vector/","text":"Vector Vector is Dynamic array structure in c++ Operations & time complexity Member Function Running Time push_back() $O(1) amortized$ pop_back() $O(1)$ empty() $O(1)$ reserve() $O(n)$ operator [] $O(1)$ Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 using size_t = unsigned long ; template < typename T > class Vector { size_t _size ; size_t _capacity ; T * _buf ; public : // constructors // Vector(SomeType); //\"ordinary constructor\" Vector ( int k ) { _size = k ; _capacity = k ; _buf = new T [ _capacity ]; } // Vector(); //default constructor Vector () { _size = 0 ; _capacity = 0 ; _buf = new T [ _capacity ]; } // Vector(const &X); // copy constructor // Vector(&&X); //move constructor // &Vector operator=(const Vector&); //copy assignment: cleanup target and copy // &Vector operator=(Vector&&); // move assignment: cleanup target and move //~Vector(); //destructor: cleanup ~ Vector () { delete [] _buf ; } // capacity: size_t size () { return _size ; } void resize ( size_t n ) { _size = n ; } size_t capacity () { return _capacity ; }; bool empty () { return _size == 0 ; }; // unsigned int max_size(); void reserve ( size_t n ) { //Requests that the vector capacity be at least enough to contain n elements. if ( _size >= n ) return ; T * _temp = new T [ n ]; for ( size_t i = 0 ; i < _size ; i ++ ) { _temp [ i ] = _buf [ i ]; } _capacity = n ; delete [] _buf ; _buf = _temp ; } // shrink_to_fit() //element access: T back (); // operator[]() T & operator []( int idx ) { return _buf [ idx ]; } T operator []( int idx ) const { return _buf [ idx ]; } // at() // front() // data() //Modifiers void clear () { resize ( 0 ); }; void push_back ( T const & val ) { if ( _size == _capacity ) { if ( _capacity ) { reserve ( _capacity << 1 ); } else { reserve ( 1 ); } } _buf [ _size ++ ] = val ; }; void pop_back () { _size -- ; }; // assign() // insert() // erase() // emplace() // emplace_back //Iterators T * begin () { return & _buf [ 0 ]; } T * end () { return & _buf [ 0 ] + _size ; }; //T* rbegin(); //T* rend(); //T* const cbegin(); //T* const cend(); //T* const crbegin(); //T* const crend(); }; Related Problems Letters Shop Related Topics Stack Analysis (Later..) You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $ Contributers 08.13.2019 jchrys","title":"Vector"},{"location":"DataStructures/Linear/Vector/#vector","text":"Vector is Dynamic array structure in c++","title":"Vector"},{"location":"DataStructures/Linear/Vector/#operations-time-complexity","text":"Member Function Running Time push_back() $O(1) amortized$ pop_back() $O(1)$ empty() $O(1)$ reserve() $O(n)$ operator [] $O(1)$","title":"Operations &amp; time complexity"},{"location":"DataStructures/Linear/Vector/#implementation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 using size_t = unsigned long ; template < typename T > class Vector { size_t _size ; size_t _capacity ; T * _buf ; public : // constructors // Vector(SomeType); //\"ordinary constructor\" Vector ( int k ) { _size = k ; _capacity = k ; _buf = new T [ _capacity ]; } // Vector(); //default constructor Vector () { _size = 0 ; _capacity = 0 ; _buf = new T [ _capacity ]; } // Vector(const &X); // copy constructor // Vector(&&X); //move constructor // &Vector operator=(const Vector&); //copy assignment: cleanup target and copy // &Vector operator=(Vector&&); // move assignment: cleanup target and move //~Vector(); //destructor: cleanup ~ Vector () { delete [] _buf ; } // capacity: size_t size () { return _size ; } void resize ( size_t n ) { _size = n ; } size_t capacity () { return _capacity ; }; bool empty () { return _size == 0 ; }; // unsigned int max_size(); void reserve ( size_t n ) { //Requests that the vector capacity be at least enough to contain n elements. if ( _size >= n ) return ; T * _temp = new T [ n ]; for ( size_t i = 0 ; i < _size ; i ++ ) { _temp [ i ] = _buf [ i ]; } _capacity = n ; delete [] _buf ; _buf = _temp ; } // shrink_to_fit() //element access: T back (); // operator[]() T & operator []( int idx ) { return _buf [ idx ]; } T operator []( int idx ) const { return _buf [ idx ]; } // at() // front() // data() //Modifiers void clear () { resize ( 0 ); }; void push_back ( T const & val ) { if ( _size == _capacity ) { if ( _capacity ) { reserve ( _capacity << 1 ); } else { reserve ( 1 ); } } _buf [ _size ++ ] = val ; }; void pop_back () { _size -- ; }; // assign() // insert() // erase() // emplace() // emplace_back //Iterators T * begin () { return & _buf [ 0 ]; } T * end () { return & _buf [ 0 ] + _size ; }; //T* rbegin(); //T* rend(); //T* const cbegin(); //T* const cend(); //T* const crbegin(); //T* const crend(); };","title":"Implementation"},{"location":"DataStructures/Linear/Vector/#related-problems","text":"Letters Shop","title":"Related Problems"},{"location":"DataStructures/Linear/Vector/#related-topics","text":"Stack","title":"Related Topics"},{"location":"DataStructures/Linear/Vector/#analysis-later","text":"You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $","title":"Analysis (Later..)"},{"location":"DataStructures/Linear/Vector/#contributers","text":"08.13.2019 jchrys","title":"Contributers"},{"location":"DataStructures/Trees/BST/","text":"Binary Search Tree A Search tree is called Binary Search if it satisfies BST property and it's #children $\\leq$ 2. Binary Search Tree Property Let $x$ be a node in a binary search tree. If $y$ is a node in the left subtree of $x$, then $y.key \\leq x.key$. If $y$ is a node in the right subtree of $x$, then $y.key \\leq x.key$. Operations & timeComplexity $h = height(tree)$ Member Function Running Time insert() $\\Omicron(h)$ erase() $\\Omicron(h)$ inorder_tree_walk $\\Theta(n)$ find() $\\Omicron(h)$ minimum() $\\Omicron(h)$ maximum() $\\Omicron(h)$ successor() $\\Omicron(h)$ predecessor() $\\Omicron(h)$ Warning it is not guaranteed that $h = \\Omicron(log(n))$ this binary search tree is not balanced Implementation c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #include <iostream> using namespace std ; template < typename T > class Set { struct Node { T key ; Node * parent ; Node * left ; Node * right ; Node ( T key ) { this -> key = key ; this -> parent = 0 ; this -> left = 0 ; this -> right = 0 ; } }; Node * root ; unsigned int _size ; public : Set () : root ( 0 ), _size ( 0 ) { //default constructor } void insert ( T key ) { _insert ( new Node ( key )); //insert a key in to set (helper function) } void _insert ( Node * && node ) { // Node * y = 0 ; Node * x = this -> root ; while ( x != 0 ) { y = x ; if ( node -> key < x -> key ) { x = x -> left ; } else if ( node -> key == x -> key ) { return ; } else { x = x -> right ; } } node -> parent = y ; if ( y == 0 ) // when tree is empty -> you could check with _size; this -> root = node ; else if ( node -> key < y -> key ) { y -> left = node ; node -> parent = y ; } else { y -> right = node ; node -> parent = y ; } this -> _size ++ ; } Node * find ( T key ) { Node * x = this -> root ; while ( x != 0 && x -> key != key ) { if ( x -> key > key ) { x = x -> left ; } else { x = x -> right ; } } return x ; } Node * minimum () { _minimum ( this -> root ); } Node * _minimum ( Node * x ) { while ( x -> left != 0 ) { x = x -> left ; } return x ; } Node * maximum () { //returns Node* that with maximum key return _maximum ( this -> root ); } Node * _maximum ( Node * & x ) { while ( x -> right != 0 ) { x = x -> right ; } return x ; } Node * successor ( Node * x ) { if ( x -> right != 0 ) { return _minimum ( x -> right ); } Node * y = x -> parent ; while ( y != 0 && x == y -> right ) { x = y ; y = y -> parent ; } return y ; } Node * predecessor ( Node * x ) { if ( x -> left != 0 ) { return _maximum ( x -> left ); } Node * y = x -> parent ; while ( y != 0 && x == y -> left ) { x = y ; y = y -> parent ; } return y ; } unsigned int size () { return _size ; } void _inorder_tree_travel ( Node * const & node ) { if ( node == 0 ) return ; _inorder_tree_travel ( node -> left ); cout << node -> key << ' ' ; _inorder_tree_travel ( node -> right ); } void inorder_tree_travel () { _inorder_tree_travel ( this -> root ); } void transplant ( Node * u , Node * v ) { if ( u -> parent == 0 ) { this -> root = v ; } else if ( u == u -> parent -> left ) { u -> parent -> left = v ; } else { u -> parent -> right = v ; } if ( v != 0 ) { v -> parent = u -> parent ; } } void erase ( T key ) { _erase ( find ( key )); } void _erase ( Node * target ) { if ( target == 0 ) return ; if ( target -> left == 0 ) transplant ( target , target -> right ); else if ( target -> right == 0 ) transplant ( target , target -> left ); else { Node * y = _minimum ( target -> right ); if ( y -> parent != target ) { transplant ( y , y -> right ); y -> right = target -> right ; y -> right -> parent = y ; } transplant ( target , y ); y -> left = target -> left ; y -> left -> parent = y ; } delete target ; _size -- ; } unsigned int height ( Node * node ) { if ( node == 0 ) return 0 ; unsigned int lDepth = height ( node -> left ); unsigned int rDepth = height ( node -> right ); if ( lDepth > rDepth ) return lDepth + 1 ; return rDepth + 1 ; } unsigned int tree_height () { return height ( this -> root ); } }; int main () { Set < int > s ; // if input's are random; cout << \"Naive Binary Search Tree implementation\" << endl ; cout << \"-------BEST-CASE(random inputs)--------\" << endl ; cout << \"input: 10,000 random integers\" << endl ; for ( int i = 0 ; i < 10000 ; i ++ ) { s . insert ( rand () % 1000000 ); } cout << \"-----------------results----------------\" << endl ; cout << \"tree_height: \" << s . tree_height () << endl ; cout << endl << endl << endl ; cout << \"------WORST-CASE(sorted_inputs)---------\" << endl ; cout << \"input: [1, 2, 3, ..., 10000]\" << endl ; Set < int > worst ; for ( int i = 1 ; i <= 10000 ; i ++ ) { worst . insert ( i ); } cout << \"-----------------results----------------\" << endl ; cout << \"tree_height: \" << worst . tree_height () << endl ; return 0 ; } Related Problems Related Topics Analysis (Later..) You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $ Contributers 08.15.2019 jchrys","title":"BST"},{"location":"DataStructures/Trees/BST/#binary-search-tree","text":"A Search tree is called Binary Search if it satisfies BST property and it's #children $\\leq$ 2.","title":"Binary Search Tree"},{"location":"DataStructures/Trees/BST/#binary-search-tree-property","text":"Let $x$ be a node in a binary search tree. If $y$ is a node in the left subtree of $x$, then $y.key \\leq x.key$. If $y$ is a node in the right subtree of $x$, then $y.key \\leq x.key$.","title":"Binary Search Tree Property"},{"location":"DataStructures/Trees/BST/#operations-timecomplexity","text":"$h = height(tree)$ Member Function Running Time insert() $\\Omicron(h)$ erase() $\\Omicron(h)$ inorder_tree_walk $\\Theta(n)$ find() $\\Omicron(h)$ minimum() $\\Omicron(h)$ maximum() $\\Omicron(h)$ successor() $\\Omicron(h)$ predecessor() $\\Omicron(h)$ Warning it is not guaranteed that $h = \\Omicron(log(n))$ this binary search tree is not balanced","title":"Operations &amp; timeComplexity"},{"location":"DataStructures/Trees/BST/#implementation-c","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #include <iostream> using namespace std ; template < typename T > class Set { struct Node { T key ; Node * parent ; Node * left ; Node * right ; Node ( T key ) { this -> key = key ; this -> parent = 0 ; this -> left = 0 ; this -> right = 0 ; } }; Node * root ; unsigned int _size ; public : Set () : root ( 0 ), _size ( 0 ) { //default constructor } void insert ( T key ) { _insert ( new Node ( key )); //insert a key in to set (helper function) } void _insert ( Node * && node ) { // Node * y = 0 ; Node * x = this -> root ; while ( x != 0 ) { y = x ; if ( node -> key < x -> key ) { x = x -> left ; } else if ( node -> key == x -> key ) { return ; } else { x = x -> right ; } } node -> parent = y ; if ( y == 0 ) // when tree is empty -> you could check with _size; this -> root = node ; else if ( node -> key < y -> key ) { y -> left = node ; node -> parent = y ; } else { y -> right = node ; node -> parent = y ; } this -> _size ++ ; } Node * find ( T key ) { Node * x = this -> root ; while ( x != 0 && x -> key != key ) { if ( x -> key > key ) { x = x -> left ; } else { x = x -> right ; } } return x ; } Node * minimum () { _minimum ( this -> root ); } Node * _minimum ( Node * x ) { while ( x -> left != 0 ) { x = x -> left ; } return x ; } Node * maximum () { //returns Node* that with maximum key return _maximum ( this -> root ); } Node * _maximum ( Node * & x ) { while ( x -> right != 0 ) { x = x -> right ; } return x ; } Node * successor ( Node * x ) { if ( x -> right != 0 ) { return _minimum ( x -> right ); } Node * y = x -> parent ; while ( y != 0 && x == y -> right ) { x = y ; y = y -> parent ; } return y ; } Node * predecessor ( Node * x ) { if ( x -> left != 0 ) { return _maximum ( x -> left ); } Node * y = x -> parent ; while ( y != 0 && x == y -> left ) { x = y ; y = y -> parent ; } return y ; } unsigned int size () { return _size ; } void _inorder_tree_travel ( Node * const & node ) { if ( node == 0 ) return ; _inorder_tree_travel ( node -> left ); cout << node -> key << ' ' ; _inorder_tree_travel ( node -> right ); } void inorder_tree_travel () { _inorder_tree_travel ( this -> root ); } void transplant ( Node * u , Node * v ) { if ( u -> parent == 0 ) { this -> root = v ; } else if ( u == u -> parent -> left ) { u -> parent -> left = v ; } else { u -> parent -> right = v ; } if ( v != 0 ) { v -> parent = u -> parent ; } } void erase ( T key ) { _erase ( find ( key )); } void _erase ( Node * target ) { if ( target == 0 ) return ; if ( target -> left == 0 ) transplant ( target , target -> right ); else if ( target -> right == 0 ) transplant ( target , target -> left ); else { Node * y = _minimum ( target -> right ); if ( y -> parent != target ) { transplant ( y , y -> right ); y -> right = target -> right ; y -> right -> parent = y ; } transplant ( target , y ); y -> left = target -> left ; y -> left -> parent = y ; } delete target ; _size -- ; } unsigned int height ( Node * node ) { if ( node == 0 ) return 0 ; unsigned int lDepth = height ( node -> left ); unsigned int rDepth = height ( node -> right ); if ( lDepth > rDepth ) return lDepth + 1 ; return rDepth + 1 ; } unsigned int tree_height () { return height ( this -> root ); } }; int main () { Set < int > s ; // if input's are random; cout << \"Naive Binary Search Tree implementation\" << endl ; cout << \"-------BEST-CASE(random inputs)--------\" << endl ; cout << \"input: 10,000 random integers\" << endl ; for ( int i = 0 ; i < 10000 ; i ++ ) { s . insert ( rand () % 1000000 ); } cout << \"-----------------results----------------\" << endl ; cout << \"tree_height: \" << s . tree_height () << endl ; cout << endl << endl << endl ; cout << \"------WORST-CASE(sorted_inputs)---------\" << endl ; cout << \"input: [1, 2, 3, ..., 10000]\" << endl ; Set < int > worst ; for ( int i = 1 ; i <= 10000 ; i ++ ) { worst . insert ( i ); } cout << \"-----------------results----------------\" << endl ; cout << \"tree_height: \" << worst . tree_height () << endl ; return 0 ; }","title":"Implementation c++"},{"location":"DataStructures/Trees/BST/#related-problems","text":"","title":"Related Problems"},{"location":"DataStructures/Trees/BST/#related-topics","text":"","title":"Related Topics"},{"location":"DataStructures/Trees/BST/#analysis-later","text":"You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $","title":"Analysis (Later..)"},{"location":"DataStructures/Trees/BST/#contributers","text":"08.15.2019 jchrys","title":"Contributers"},{"location":"DataStructures/Trees/RedBlackTree/","text":"Red Black Tree Red Black Tree is balanced binary search tree with one extra bit of storage per node: color Red Black Tree satisfies the Red-Black-Properties Red-Black-Properties Every node is black or red The root is black Every leaf(NIL) is black if a node is red, then both its children are black For each node, all simple paths from the node to descendant leaves contains the same number of black nodes. Operations & time complexity $N$ = number of elements in Tree Member Function Running Time insert() $\\Omicron(\\lg(N))$ erase() $\\Omicron(\\lg(N))$ inorder_tree_walk $\\Theta(N)$ find() $\\Omicron(\\lg(N))$ minimum() $\\Omicron(\\lg(N))$ maximum() $\\Omicron(\\lg(N))$ successor() $\\Omicron(\\lg(N))$ predecessor() $\\Omicron(\\lg(N))$ Note Red Black Tree is Balanced Binary Search Tree It is guaranteed that height of the tree is $\\Omicron(\\lg(N))$ in worst case Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #include <bits/stdc++.h> using namespace std ; template < typename K , typename V > class Map { struct Node { K key ; V val ; bool color ; // 0: red, 1:black Node * p ; Node * left ; Node * right ; Node ( Map & out ) : key (), val (), color ( 1 ), p ( out . NIL ), left ( out . NIL ), right ( out . NIL ){} Node ( Map & out , K key , V val ) : key ( key ), val ( val ), color ( 0 ), p ( out . NIL ), left ( out . NIL ), right ( out . NIL ){} }; Node * root ; void left_rotate ( Node * x ) { Node * y = x -> right ; // y is x's right child x -> right = y -> left ; // set y's left child to x's right child; x -> right -> p = x ; // set parent y -> p = x -> p ; //set x's parent pointing to y; if ( x -> p == NIL ) { // if x is root this -> root = y ; } else if ( x == x -> p -> left ) { //if x is left child x -> p -> left = y ; } else { x -> p -> right = y ; } x -> p = y ; // y is x's parent y -> left = x ; // x is y's left child } void right_rotate ( Node * x ) { Node * y = x -> left ; x -> left = y -> right ; x -> left -> p = x ; y -> p = x -> p ; if ( x -> p == NIL ) { this -> root = y ; } else if ( x == x -> p -> left ) { x -> p -> left = y ; } else { x -> p -> right = y ; } x -> p = y ; y -> right = x ; } void transplant ( Node * u , Node * v ) { // gives u's parent relations to v if ( u -> p == NIL ) { root = v ; } else if ( u == u -> p -> right ) { u -> p -> right = v ; } else { u -> p -> left = v ; } v -> p = u -> p ; // unconditionally because NIL can have parent also; } public : Node * NIL ; Map () { NIL = new Node ( * this ); root = NIL ; } void insert_fixup ( Node * & z ) { while ( z -> p -> color == 0 ) { Node * y ; // z's uncle if ( z -> p == z -> p -> p -> left ) { // when z's parent is left child y = z -> p -> p -> right ; if ( y -> color == 0 ) { // if uncle is red, uncles parent should be black z -> p -> color = 1 ; // recoloring and goes up y -> color = 1 ; z -> p -> p -> color = 0 ; z = z -> p -> p ; } else { if ( z == z -> p -> right ) { // if uncle is black and z is right child z = z -> p ; left_rotate ( z ); } // if uncle is black and z is right child z -> p -> color = 1 ; z -> p -> p -> color = 0 ; right_rotate ( z -> p -> p ); } } else { // when z's parent is right child y = z -> p -> p -> left ; if ( y -> color == 0 ) { z -> p -> color = 1 ; y -> color = 1 ; z -> p -> p -> color = 0 ; z = z -> p -> p ; } else { // if uncle's color is black if ( z == z -> p -> left ) { //when z is right child z = z -> p ; right_rotate ( z ); } z -> p -> color = 1 ; z -> p -> p -> color = 0 ; left_rotate ( z -> p -> p ); } } } this -> root -> color = 1 ; } void insert ( K key , V val ) { Node * z = new Node ( * this , key , val ); Node * y = NIL ; Node * x = this -> root ; while ( x != NIL ) { y = x ; if ( z -> key < x -> key ) { x = x -> left ; } else { x = x -> right ; } } z -> p = y ; if ( y == NIL ) { this -> root = z ; } else if ( z -> key < y -> key ) { y -> left = z ; } else { y -> right = z ; } // z->left = NIL; // z->right = ZIL; // z->color = 0; insert_fixup ( z ); } Node * find ( K key ) { Node * x = root ; while ( x != NIL && x -> key != key ) { if ( key < x -> key ) { x = x -> left ; } else { x = x -> right ; } } return x ; } Node * minimum ( Node * x ) { while ( x -> left != NIL ) { x = x -> left ; } return x ; } void erase_fixup ( Node * x ) { Node * w ; // sibling of x; while ( x != this -> root && x -> color == 1 ) { //only if x is black and not root if ( x == x -> p -> left ) { w = x -> p -> right ; if ( w -> color == 0 ) { // turns to case2, 3 or 4; w -> color = 1 ; x -> p -> color = 0 ; left_rotate ( x -> p ); w = x -> p -> right ; } if ( w -> left -> color == 1 && w -> right -> color == 1 ) { // case2 w -> color = 0 ; x = x -> p ; } else { if ( w -> right -> color == 1 ) { //case3 -> turns to case4 w -> left -> color = 1 ; w -> color = 0 ; right_rotate ( w ); w = x -> p -> right ; } w -> color = x -> p -> color ; // case4 -> we can make legit red-black tree x -> p -> color = 1 ; w -> right -> color = 1 ; left_rotate ( x -> p ); x = root ; } } else { // x == x->p->right w = x -> p -> left ; if ( w -> color == 0 ) { w -> color = 1 ; x -> p -> color = 0 ; right_rotate ( x -> p ); w = x -> p -> left ; } if ( w -> left -> color == 1 && w -> right -> color == 1 ) { w -> color = 0 ; x = x -> p ; } else { if ( w -> left -> color == 1 ) { w -> color = 0 ; w -> right -> color = 1 ; left_rotate ( w ); w = x -> p -> left ; } w -> color = w -> p -> color ; w -> p -> color = 1 ; w -> left -> color = 1 ; right_rotate ( x -> p ); x = root ; } } } x -> color = 1 ; } void erase ( Node * z ) { Node * y = z ; bool y_original_color = y -> color ; Node * x ; if ( z -> left == NIL ) { x = z -> right ; transplant ( z , z -> right ); } else if ( z -> right == NIL ) { x = z -> left ; transplant ( z , z -> left ); } else { y = minimum ( z -> right ); y_original_color = y -> color ; x = y -> right ; if ( y -> p == z ) { x -> p = y ; // incase of x is NIL!! we need to find it's parent! } else { transplant ( y , y -> right ); y -> right = z -> right ; y -> right -> p = y ; } transplant ( z , y ); y -> left = z -> left ; y -> left -> p = y ; y -> color = z -> color ; } if ( y_original_color == 1 ) { erase_fixup ( x ); } } void rb_printer ( Node * node , int indent ) { //prints red & black tree int count = 4 ; if ( node == NIL ) return ; indent += count ; rb_printer ( node -> right , indent ); cout << endl ; for ( int i = count ; i < indent ; i ++ ) { cout << \" \" ; } cout << ( node -> color == 0 ? \" \\033 [1;31m\" : \"\" ) << ( node == node -> p -> left ? \"l\" : \"r\" ) << node -> key << ( node -> color == 0 ? \" \\033 [0m\" : \"\" ) << endl ; rb_printer ( node -> left , indent ); } void print () { rb_printer ( this -> root , 0 ); } }; int main () { Map < int , int > m ; for ( int i = 0 ; i < 20 ; i ++ ) { m . insert ( rand () % 20 , 1 ); } m . print (); cout << \"deleting ---\" << endl ;; for ( int i = 0 ; i < 20 ; i ++ ) { int key = rand () % 20 ; auto it = m . find ( key ); cout << \"delete: \" << key << endl ; if ( it != m . NIL ) { cout << \"key exist... deleting...\" ; m . erase ( it ); m . print (); } else { cout << \"key not exist\" << endl ; } } return 0 ; } Related Problems NOT ADDED YET Related Topics BinarySearchTree Analysis (Optional) You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $ Contributers (Optional) 08.18.2019 JCHRYS","title":"RedBlackTree"},{"location":"DataStructures/Trees/RedBlackTree/#red-black-tree","text":"Red Black Tree is balanced binary search tree with one extra bit of storage per node: color Red Black Tree satisfies the Red-Black-Properties Red-Black-Properties Every node is black or red The root is black Every leaf(NIL) is black if a node is red, then both its children are black For each node, all simple paths from the node to descendant leaves contains the same number of black nodes.","title":"Red Black Tree"},{"location":"DataStructures/Trees/RedBlackTree/#operations-time-complexity","text":"$N$ = number of elements in Tree Member Function Running Time insert() $\\Omicron(\\lg(N))$ erase() $\\Omicron(\\lg(N))$ inorder_tree_walk $\\Theta(N)$ find() $\\Omicron(\\lg(N))$ minimum() $\\Omicron(\\lg(N))$ maximum() $\\Omicron(\\lg(N))$ successor() $\\Omicron(\\lg(N))$ predecessor() $\\Omicron(\\lg(N))$ Note Red Black Tree is Balanced Binary Search Tree It is guaranteed that height of the tree is $\\Omicron(\\lg(N))$ in worst case","title":"Operations &amp; time complexity"},{"location":"DataStructures/Trees/RedBlackTree/#implementation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #include <bits/stdc++.h> using namespace std ; template < typename K , typename V > class Map { struct Node { K key ; V val ; bool color ; // 0: red, 1:black Node * p ; Node * left ; Node * right ; Node ( Map & out ) : key (), val (), color ( 1 ), p ( out . NIL ), left ( out . NIL ), right ( out . NIL ){} Node ( Map & out , K key , V val ) : key ( key ), val ( val ), color ( 0 ), p ( out . NIL ), left ( out . NIL ), right ( out . NIL ){} }; Node * root ; void left_rotate ( Node * x ) { Node * y = x -> right ; // y is x's right child x -> right = y -> left ; // set y's left child to x's right child; x -> right -> p = x ; // set parent y -> p = x -> p ; //set x's parent pointing to y; if ( x -> p == NIL ) { // if x is root this -> root = y ; } else if ( x == x -> p -> left ) { //if x is left child x -> p -> left = y ; } else { x -> p -> right = y ; } x -> p = y ; // y is x's parent y -> left = x ; // x is y's left child } void right_rotate ( Node * x ) { Node * y = x -> left ; x -> left = y -> right ; x -> left -> p = x ; y -> p = x -> p ; if ( x -> p == NIL ) { this -> root = y ; } else if ( x == x -> p -> left ) { x -> p -> left = y ; } else { x -> p -> right = y ; } x -> p = y ; y -> right = x ; } void transplant ( Node * u , Node * v ) { // gives u's parent relations to v if ( u -> p == NIL ) { root = v ; } else if ( u == u -> p -> right ) { u -> p -> right = v ; } else { u -> p -> left = v ; } v -> p = u -> p ; // unconditionally because NIL can have parent also; } public : Node * NIL ; Map () { NIL = new Node ( * this ); root = NIL ; } void insert_fixup ( Node * & z ) { while ( z -> p -> color == 0 ) { Node * y ; // z's uncle if ( z -> p == z -> p -> p -> left ) { // when z's parent is left child y = z -> p -> p -> right ; if ( y -> color == 0 ) { // if uncle is red, uncles parent should be black z -> p -> color = 1 ; // recoloring and goes up y -> color = 1 ; z -> p -> p -> color = 0 ; z = z -> p -> p ; } else { if ( z == z -> p -> right ) { // if uncle is black and z is right child z = z -> p ; left_rotate ( z ); } // if uncle is black and z is right child z -> p -> color = 1 ; z -> p -> p -> color = 0 ; right_rotate ( z -> p -> p ); } } else { // when z's parent is right child y = z -> p -> p -> left ; if ( y -> color == 0 ) { z -> p -> color = 1 ; y -> color = 1 ; z -> p -> p -> color = 0 ; z = z -> p -> p ; } else { // if uncle's color is black if ( z == z -> p -> left ) { //when z is right child z = z -> p ; right_rotate ( z ); } z -> p -> color = 1 ; z -> p -> p -> color = 0 ; left_rotate ( z -> p -> p ); } } } this -> root -> color = 1 ; } void insert ( K key , V val ) { Node * z = new Node ( * this , key , val ); Node * y = NIL ; Node * x = this -> root ; while ( x != NIL ) { y = x ; if ( z -> key < x -> key ) { x = x -> left ; } else { x = x -> right ; } } z -> p = y ; if ( y == NIL ) { this -> root = z ; } else if ( z -> key < y -> key ) { y -> left = z ; } else { y -> right = z ; } // z->left = NIL; // z->right = ZIL; // z->color = 0; insert_fixup ( z ); } Node * find ( K key ) { Node * x = root ; while ( x != NIL && x -> key != key ) { if ( key < x -> key ) { x = x -> left ; } else { x = x -> right ; } } return x ; } Node * minimum ( Node * x ) { while ( x -> left != NIL ) { x = x -> left ; } return x ; } void erase_fixup ( Node * x ) { Node * w ; // sibling of x; while ( x != this -> root && x -> color == 1 ) { //only if x is black and not root if ( x == x -> p -> left ) { w = x -> p -> right ; if ( w -> color == 0 ) { // turns to case2, 3 or 4; w -> color = 1 ; x -> p -> color = 0 ; left_rotate ( x -> p ); w = x -> p -> right ; } if ( w -> left -> color == 1 && w -> right -> color == 1 ) { // case2 w -> color = 0 ; x = x -> p ; } else { if ( w -> right -> color == 1 ) { //case3 -> turns to case4 w -> left -> color = 1 ; w -> color = 0 ; right_rotate ( w ); w = x -> p -> right ; } w -> color = x -> p -> color ; // case4 -> we can make legit red-black tree x -> p -> color = 1 ; w -> right -> color = 1 ; left_rotate ( x -> p ); x = root ; } } else { // x == x->p->right w = x -> p -> left ; if ( w -> color == 0 ) { w -> color = 1 ; x -> p -> color = 0 ; right_rotate ( x -> p ); w = x -> p -> left ; } if ( w -> left -> color == 1 && w -> right -> color == 1 ) { w -> color = 0 ; x = x -> p ; } else { if ( w -> left -> color == 1 ) { w -> color = 0 ; w -> right -> color = 1 ; left_rotate ( w ); w = x -> p -> left ; } w -> color = w -> p -> color ; w -> p -> color = 1 ; w -> left -> color = 1 ; right_rotate ( x -> p ); x = root ; } } } x -> color = 1 ; } void erase ( Node * z ) { Node * y = z ; bool y_original_color = y -> color ; Node * x ; if ( z -> left == NIL ) { x = z -> right ; transplant ( z , z -> right ); } else if ( z -> right == NIL ) { x = z -> left ; transplant ( z , z -> left ); } else { y = minimum ( z -> right ); y_original_color = y -> color ; x = y -> right ; if ( y -> p == z ) { x -> p = y ; // incase of x is NIL!! we need to find it's parent! } else { transplant ( y , y -> right ); y -> right = z -> right ; y -> right -> p = y ; } transplant ( z , y ); y -> left = z -> left ; y -> left -> p = y ; y -> color = z -> color ; } if ( y_original_color == 1 ) { erase_fixup ( x ); } } void rb_printer ( Node * node , int indent ) { //prints red & black tree int count = 4 ; if ( node == NIL ) return ; indent += count ; rb_printer ( node -> right , indent ); cout << endl ; for ( int i = count ; i < indent ; i ++ ) { cout << \" \" ; } cout << ( node -> color == 0 ? \" \\033 [1;31m\" : \"\" ) << ( node == node -> p -> left ? \"l\" : \"r\" ) << node -> key << ( node -> color == 0 ? \" \\033 [0m\" : \"\" ) << endl ; rb_printer ( node -> left , indent ); } void print () { rb_printer ( this -> root , 0 ); } }; int main () { Map < int , int > m ; for ( int i = 0 ; i < 20 ; i ++ ) { m . insert ( rand () % 20 , 1 ); } m . print (); cout << \"deleting ---\" << endl ;; for ( int i = 0 ; i < 20 ; i ++ ) { int key = rand () % 20 ; auto it = m . find ( key ); cout << \"delete: \" << key << endl ; if ( it != m . NIL ) { cout << \"key exist... deleting...\" ; m . erase ( it ); m . print (); } else { cout << \"key not exist\" << endl ; } } return 0 ; }","title":"Implementation"},{"location":"DataStructures/Trees/RedBlackTree/#related-problems","text":"NOT ADDED YET","title":"Related Problems"},{"location":"DataStructures/Trees/RedBlackTree/#related-topics","text":"BinarySearchTree","title":"Related Topics"},{"location":"DataStructures/Trees/RedBlackTree/#analysis-optional","text":"You can add some mathematical things here using KaTex as a block tag $$ T(N) = O(N*M) $$ or as a inline tag $T(N) = O(N) $","title":"Analysis (Optional)"},{"location":"DataStructures/Trees/RedBlackTree/#contributers-optional","text":"08.18.2019 JCHRYS","title":"Contributers (Optional)"},{"location":"DataStructures/Trees/SearchTree/","text":"Search Tree The Search tree data structure supports many dynamic-set operations, including $SEARCH,\\ MINIMUM,\\ MAXIMUM,\\ PREDECESSOR,$ $ SUCCESSOR,\\ INSERT,\\ DELETE$ so we can use a search tree as a $dictionary$ and as a $priority\\ queue$ DataStructure We can represent it as linked objects Each Node Containing Each Node Contatining pointers : rightChild , leftChild , parent","title":"SearchTree"},{"location":"DataStructures/Trees/SearchTree/#search-tree","text":"The Search tree data structure supports many dynamic-set operations, including $SEARCH,\\ MINIMUM,\\ MAXIMUM,\\ PREDECESSOR,$ $ SUCCESSOR,\\ INSERT,\\ DELETE$ so we can use a search tree as a $dictionary$ and as a $priority\\ queue$","title":"Search Tree"},{"location":"DataStructures/Trees/SearchTree/#datastructure","text":"We can represent it as linked objects","title":"DataStructure"},{"location":"DataStructures/Trees/SearchTree/#each-node-containing","text":"Each Node Contatining pointers : rightChild , leftChild , parent","title":"Each Node Containing"},{"location":"Language/Class/","text":"Class C++ classes are a tool for creating new types that can be used conveniently as builtin types The Fundamental idea in defining a new type is to separate the details of the implementation from the properties essential to the correc use of it Brief Summary of classes A class is user-defined type A class consists of a set of members. The most common kinds of members are data members and member functions. Member functions can define the meaning of initialization, copy, move, and cleanup Members are accessed using . (dot) for objects and -> (arrow) for pointers. Operators, such as, + , ! , and [] , can be defined for a class A class is a namespace containing its members The public members provide the class's interface and the private members provide implementation details A struct is a class where members are by default public Class Basics class example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class X { private : // the representation (implementation) is private int m ; public : // the user interface is public X ( int i = 0 ) : m { i } {} //a constructor (initialize the data member m) int mf ( int i ) { // a member function int old = m ; m = i ; //set a new value return old ; // return the old value } }; X var { 7 }; // a variable of type X, initialized to 7 int user ( X var , X * ptr ) { int x = var . mf ( 7 ); // access using . int y = ptr -> mf ( 9 ); // access using -> int z = var . m ; // error: cannot acces private member } 1. Member functions Functions declared within a class definition are called member functions 2. Default copying a class object can be initialized with a copy of an obejct of its class 1 2 UserClass c1 = c0 ; // initialization by copy UserClass c2 { d1 }; // initialization by copy 3. Access Control class is consist of two parts private part: can be used only by member functions , public part : interface to objects of class 4. class and struct a struct is a class in which members are by default public struct S{}; is simply short hand for class S{public: }; 5. Constructors a constructor is recognized by having the same name as the class it self. programmers can declare a function with the explicit purpose of initializing objects. 1 2 3 4 5 6 7 8 9 10 11 12 class Date { int d , m , y ; public : Date ( int dd , int mm , int yy ); // constructor } Date today = Date ( 23 , 6 , 1983 ); // OK Date xmas ( 25 , 12 , 1990 ); // OK -> abbreviated form Date my_birthday ; //error: initializer missing Date release1_0 ( 10 , 12 ) //error: third argument missing Date today = Date { 23 , 6 , 1982 } // good! I recommend the {} notation over the () notation for initializing, because it is explicit about what is being done we could use default values directly as default arguments 1 2 3 4 5 class Date { int d , m , y ; public : Date ( int dd = today . d , int mm = today . m , int yy = today . y ); // constructor }","title":"Class"},{"location":"Language/Class/#class","text":"C++ classes are a tool for creating new types that can be used conveniently as builtin types The Fundamental idea in defining a new type is to separate the details of the implementation from the properties essential to the correc use of it","title":"Class"},{"location":"Language/Class/#brief-summary-of-classes","text":"A class is user-defined type A class consists of a set of members. The most common kinds of members are data members and member functions. Member functions can define the meaning of initialization, copy, move, and cleanup Members are accessed using . (dot) for objects and -> (arrow) for pointers. Operators, such as, + , ! , and [] , can be defined for a class A class is a namespace containing its members The public members provide the class's interface and the private members provide implementation details A struct is a class where members are by default public","title":"Brief Summary of classes"},{"location":"Language/Class/#class-basics","text":"","title":"Class Basics"},{"location":"Language/Class/#class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class X { private : // the representation (implementation) is private int m ; public : // the user interface is public X ( int i = 0 ) : m { i } {} //a constructor (initialize the data member m) int mf ( int i ) { // a member function int old = m ; m = i ; //set a new value return old ; // return the old value } }; X var { 7 }; // a variable of type X, initialized to 7 int user ( X var , X * ptr ) { int x = var . mf ( 7 ); // access using . int y = ptr -> mf ( 9 ); // access using -> int z = var . m ; // error: cannot acces private member }","title":"class example"},{"location":"Language/Class/#1-member-functions","text":"Functions declared within a class definition are called member functions","title":"1. Member functions"},{"location":"Language/Class/#2-default-copying","text":"a class object can be initialized with a copy of an obejct of its class 1 2 UserClass c1 = c0 ; // initialization by copy UserClass c2 { d1 }; // initialization by copy","title":"2. Default copying"},{"location":"Language/Class/#3-access-control","text":"class is consist of two parts private part: can be used only by member functions , public part : interface to objects of class","title":"3. Access Control"},{"location":"Language/Class/#4-class-and-struct","text":"a struct is a class in which members are by default public struct S{}; is simply short hand for class S{public: };","title":"4. class and struct"},{"location":"Language/Class/#5-constructors","text":"a constructor is recognized by having the same name as the class it self. programmers can declare a function with the explicit purpose of initializing objects. 1 2 3 4 5 6 7 8 9 10 11 12 class Date { int d , m , y ; public : Date ( int dd , int mm , int yy ); // constructor } Date today = Date ( 23 , 6 , 1983 ); // OK Date xmas ( 25 , 12 , 1990 ); // OK -> abbreviated form Date my_birthday ; //error: initializer missing Date release1_0 ( 10 , 12 ) //error: third argument missing Date today = Date { 23 , 6 , 1982 } // good! I recommend the {} notation over the () notation for initializing, because it is explicit about what is being done we could use default values directly as default arguments 1 2 3 4 5 class Date { int d , m , y ; public : Date ( int dd = today . d , int mm = today . m , int yy = today . y ); // constructor }","title":"5. Constructors"},{"location":"Language/Keywords/","text":"Aliases Aliases are used when we want to insulate our code from details of the underlying machine. - note that naming a type after its representation than its purpose is not neccessarily a good idea. 1. typedef 1 2 cpp typedef double decimal_places ; // is equivalent to \"using decimal_places = double;\" 2. using the using keyword can also be used to introduce a template alias. 1 2 template < typename T > using Vector = std :: vector < T , my_allocator < T >> but we cannot apply type specifiers, such as unsigned, to an alias. 1 2 3 using Char = char ; using Uchar = unsigned Char ; //error using Uchar = unsigned char ; // ok","title":"Keywords"},{"location":"Language/Keywords/#aliases","text":"Aliases are used when we want to insulate our code from details of the underlying machine. - note that naming a type after its representation than its purpose is not neccessarily a good idea.","title":"Aliases"},{"location":"Language/Keywords/#1-typedef","text":"1 2 cpp typedef double decimal_places ; // is equivalent to \"using decimal_places = double;\"","title":"1. typedef"},{"location":"Language/Keywords/#2-using","text":"the using keyword can also be used to introduce a template alias. 1 2 template < typename T > using Vector = std :: vector < T , my_allocator < T >> but we cannot apply type specifiers, such as unsigned, to an alias. 1 2 3 using Char = char ; using Uchar = unsigned Char ; //error using Uchar = unsigned char ; // ok","title":"2. using"},{"location":"Language/Preface/","text":"Why C++? What You Should Know Before.. you should be able to write C++ programs using components such as IOstreams and containers from C++ STL. You Should be also be familiar with the basic features of \"Modern C++\", such as auto, decltype, move semantics, and lambdas. c++17 modern C++ We will use number of these new features of modern C++ 1. C++11 Variadic templates Alias templates Move semantics, rvalue references, and perfect forwarding Standard type traits 2. C++14 Variable templates Generic Lambdas 3. C++17 Class template argument deduction Compile-time if Fold expressions Style Guide 1. the order of constant qualifier. What is in front of const qualifier is always a constant 1 2 int const MAX_SIZE = 100 ; // the int is constant int * const P ; // the pointer cannot change, but int value can; 1 2 const int MAX_SIZE = 100 ; const int * P ; // you can not find what's constant value; reason1. easy to know what's constant. it's always what is in front of the const qualifier reason2. syntatical substitution principle. consider following example 1 2 3 4 5 6 7 typedef char * CHARS ; typedef CHARS const CPTR ; // constant pointer to chars // => typedef char * const CPTR ; using CHARS = char * : using CPTR = CHARS const ; // constant pointer to chars // => using CPTR = char * const ; The meaning of the second declaration is preseved when we textually replace CHARS with what it stands for; How ever if you write const before the type it qualifies. textually 1 2 3 typedef char * CHARS ; typedef const CHARS CTPR ; //const pointer to chars; // => typedef const char* CTPR // pointer to constant chars; footnote: note that typedef defines a \"type alias\" rather than a new type 1 2 3 4 typedef int newInt ; int i = 29 ; newInt j = 1999 ; i = j ; // OK 2. put the space between the & and the parameter name; by doing this, we emphasize the separation between the parameter type and the parameter name. 1 void foo ( int const & x ); 3. avoid declaring multiple entities in this way!. 1 char * a , b ; according to the rules inherited from C, a is a pointer but b is an ordinary char ;","title":"Preface"},{"location":"Language/Preface/#why-c","text":"","title":"Why C++?"},{"location":"Language/Preface/#what-you-should-know-before","text":"you should be able to write C++ programs using components such as IOstreams and containers from C++ STL. You Should be also be familiar with the basic features of \"Modern C++\", such as auto, decltype, move semantics, and lambdas. c++17","title":"What You Should Know Before.."},{"location":"Language/Preface/#modern-c","text":"We will use number of these new features of modern C++","title":"modern C++"},{"location":"Language/Preface/#1-c11","text":"Variadic templates Alias templates Move semantics, rvalue references, and perfect forwarding Standard type traits","title":"1. C++11"},{"location":"Language/Preface/#2-c14","text":"Variable templates Generic Lambdas","title":"2. C++14"},{"location":"Language/Preface/#3-c17","text":"Class template argument deduction Compile-time if Fold expressions","title":"3. C++17"},{"location":"Language/Preface/#style-guide","text":"","title":"Style Guide"},{"location":"Language/Preface/#1-the-order-of-constant-qualifier","text":"What is in front of const qualifier is always a constant 1 2 int const MAX_SIZE = 100 ; // the int is constant int * const P ; // the pointer cannot change, but int value can; 1 2 const int MAX_SIZE = 100 ; const int * P ; // you can not find what's constant value; reason1. easy to know what's constant. it's always what is in front of the const qualifier reason2. syntatical substitution principle. consider following example 1 2 3 4 5 6 7 typedef char * CHARS ; typedef CHARS const CPTR ; // constant pointer to chars // => typedef char * const CPTR ; using CHARS = char * : using CPTR = CHARS const ; // constant pointer to chars // => using CPTR = char * const ; The meaning of the second declaration is preseved when we textually replace CHARS with what it stands for; How ever if you write const before the type it qualifies. textually 1 2 3 typedef char * CHARS ; typedef const CHARS CTPR ; //const pointer to chars; // => typedef const char* CTPR // pointer to constant chars; footnote: note that typedef defines a \"type alias\" rather than a new type 1 2 3 4 typedef int newInt ; int i = 29 ; newInt j = 1999 ; i = j ; // OK","title":"1. the order of constant qualifier."},{"location":"Language/Preface/#2-put-the-space-between-the-amp-and-the-parameter-name","text":"by doing this, we emphasize the separation between the parameter type and the parameter name. 1 void foo ( int const & x );","title":"2. put the space between the &amp; and the parameter name;"},{"location":"Language/Preface/#3-avoid-declaring-multiple-entities-in-this-way","text":"1 char * a , b ; according to the rules inherited from C, a is a pointer but b is an ordinary char ;","title":"3. avoid declaring multiple entities in this way!."},{"location":"MISC/Lemma/","text":"Lemma Lemma-1 if we run $dfs(root)$ in a rooted tree, then v is an ancestor of $u$ if and only if $st_v\\leq st_u\\leq ft_u\\leq ft_v$. Lemma-2","title":"Lemma"},{"location":"MISC/Lemma/#lemma","text":"","title":"Lemma"},{"location":"MISC/Lemma/#lemma-1","text":"if we run $dfs(root)$ in a rooted tree, then v is an ancestor of $u$ if and only if $st_v\\leq st_u\\leq ft_u\\leq ft_v$.","title":"Lemma-1"},{"location":"MISC/Lemma/#lemma-2","text":"","title":"Lemma-2"}]}